{
  "tasks": [
    {
      "id": 1,
      "title": "BE: Project Setup & Basic Express Server",
      "description": "Initialize the Node.js backend project with Express.js. Set up project structure, linting (e.g., ESLint), formatting (e.g., Prettier), and a basic Express server that listens on a port. This forms the absolute foundation for all backend development.",
      "details": "Initialize a new Node.js project (`npm init -y`). Install Express (`npm install express`). Create a main server file (e.g., `server.js` or `app.js`) to set up a basic Express app: `const express = require('express'); const app = express(); const PORT = process.env.PORT || 3000; app.get('/', (req, res) => res.send('Exchange Backend Running')); app.listen(PORT, () => console.log(`Server running on port ${PORT}`));`. Set up scripts in `package.json` for starting the server (e.g., `dev` script using `nodemon`). Configure ESLint and Prettier for code consistency.",
      "testStrategy": "Verify that the Node.js project is initialized, Express is installed, and the basic server starts without errors, responding to a GET request at the root path. Linting and formatting tools should be configurable.",
      "priority": "high",
      "dependencies": [],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 2,
      "title": "BE: Database Selection & Initial Schema Design (Users, Cryptocurrencies, Balances)",
      "description": "Research and finalize the choice of database (leaning PostgreSQL as per PRD). Design the initial database schema for core entities: Users, Cryptocurrencies, Accounts (for fiat balances), and CryptoHoldings (for crypto balances). Implement migration scripts to create these tables.",
      "details": "Confirm PostgreSQL as the database. Install PostgreSQL locally or set up a cloud instance. Install the `pg` Node.js driver (`npm install pg`). Design schema: `Users` (user_id, email, password_hash, role, created_at, updated_at), `Cryptocurrencies` (cryptocurrency_id, symbol, name, description, is_active), `Accounts` (account_id, user_id FK, currency_code (e.g., 'SIM_USD'), balance DECIMAL, created_at, updated_at), `CryptoHoldings` (holding_id, user_id FK, cryptocurrency_id FK, balance DECIMAL, created_at, updated_at). Write SQL scripts or use a migration tool (e.g., `node-pg-migrate`) to create these tables.",
      "testStrategy": "Verify database connection from the Node.js application. Confirm that all specified tables and columns are created correctly in PostgreSQL with appropriate data types and constraints (primary keys, foreign keys, unique constraints).",
      "priority": "high",
      "dependencies": [
        1
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 3,
      "title": "BE: User Authentication Endpoints (Registration, Login)",
      "description": "Implement backend logic for user registration and login. This includes creating a User model, handling password hashing (e.g., using bcryptjs or argon2), storing user data, verifying credentials, and generating session tokens (JWT) or setting up cookie-based sessions.",
      "details": "Create `/auth/register` and `/auth/login` Express routes. For registration: validate input (email, password), hash password using `bcryptjs` (`npm install bcryptjs`), store user in `Users` table. For login: find user by email, compare hashed password, if valid, generate a JWT (`npm install jsonwebtoken`) containing user_id and role. Return token to client. Define User model functions for DB interactions (e.g., `createUser`, `findUserByEmail`).",
      "testStrategy": "Test registration endpoint: new user created in DB, password hashed. Test login endpoint: valid credentials return a token/session, invalid credentials return an error. Check token content.",
      "priority": "high",
      "dependencies": [
        2
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 4,
      "title": "BE: Authentication & Authorization Middleware",
      "description": "Implement middleware for session-based authentication to protect routes that require a logged-in user. The primary focus for this task is on implementing robust authentication middleware. Role-based authorization (e.g., admin/user distinctions) is deferred for now. Ownership-based access control, where necessary, will be handled within specific route handlers rather than a generic authorization middleware.",
      "status": "done",
      "dependencies": [
        3
      ],
      "priority": "high",
      "details": "Create an `authMiddleware` function. This function should:\n1. Check for an active session (e.g., by inspecting `req.session` and verifying the presence of `req.session.userId`).\n2. If a valid session exists (e.g., `req.session.userId` is present), ensure user information (e.g., user ID from `req.session.userId`, role from `req.session.role`) is readily accessible for subsequent handlers. This can be achieved by populating `req.user` (e.g., `req.user = { id: req.session.userId, role: req.session.role }`) or by ensuring route handlers can directly and reliably use `req.session` for this information.\n3. If authentication fails (no active session, or session data is invalid/missing required fields like `userId`), the middleware should send an appropriate error response (e.g., 401 Unauthorized).\n4. Apply this `authMiddleware` to all routes that require a user to be logged in.\nNote: General role-based authorization middleware (e.g., checking for 'admin' vs 'user' roles) is deferred. Specific access control logic, such as ownership checks, will be implemented directly within the relevant route handlers after authentication, using the user information made available by this session-based middleware.",
      "testStrategy": "1. Test that protected routes return a 401 Unauthorized status code when no active session is present (e.g., no session cookie sent, or session store does not recognize the session ID).\n2. Test that protected routes return a 401 Unauthorized status code when a session exists but is invalid or lacks essential user identifiers (e.g., `req.session.userId` is missing).\n3. Test that protected routes allow access (e.g., return a 2xx status code or proceed to the next handler) when a valid session with required user information (e.g., `req.session.userId`) is present.\n4. Verify that user information (e.g., `req.user` if populated, or directly via `req.session`) is correctly populated and accessible with user details (ID, role) after successful session validation.\n(Role-based authorization tests are deferred for this task).",
      "subtasks": []
    },
    {
      "id": 5,
      "title": "FE: Svelte Project Setup & Basic UI Shell",
      "description": "Set up the Svelte frontend project (or SvelteKit if preferred). Create a basic application shell with main layout components (e.g., navbar, footer, main content area) and set up client-side routing if using SvelteKit or a separate router.",
      "details": "Initialize a Svelte project: `npx degit sveltejs/template my-svelte-project` or `npm create svelte@latest my-sveltekit-project`. Set up basic folder structure (components, routes/pages, stores). Create `Navbar.svelte`, `Footer.svelte`, and an `App.svelte` or `+layout.svelte` to structure the main UI. If not using SvelteKit, install a router like `svelte-routing`.",
      "testStrategy": "Verify the Svelte application runs locally. Basic layout components should render. Navigation (if set up) should switch between placeholder pages.",
      "priority": "high",
      "dependencies": [],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 6,
      "title": "FE: User Authentication UI & Logic",
      "description": "Develop Svelte components for user registration and login forms. Implement logic to capture user input, perform client-side validation, and use the `fetch` API to send credentials to the backend authentication endpoints. Manage client-side user session (e.g., store JWT in localStorage, update UI based on auth state).",
      "details": "Create `Register.svelte` and `Login.svelte` components with input fields and submit buttons. Use Svelte stores (e.g., `writable`) for managing user authentication state (token, user info). On form submission, use `fetch` to POST to `/auth/register` or `/auth/login`. Handle responses: store token in localStorage on success, display errors on failure. Implement logout functionality (clear token, reset auth state). Conditionally render UI elements based on auth state (e.g., show Login/Register or Logout/Profile links).",
      "testStrategy": "User can register via the form, data sent to backend. User can log in, token received and stored. UI updates based on login status. Logout clears session. Error messages displayed for invalid input/credentials.",
      "priority": "high",
      "dependencies": [
        3,
        5
      ],
      "status": "done",
      "subtasks": [
        {
          "id": 1,
          "title": "Create Register.svelte Component",
          "description": "Develop the `Register.svelte` component, including form inputs for user registration (e.g., email, password, confirm password) and implement client-side validation logic for these inputs.",
          "dependencies": [],
          "details": "Form fields: username (optional), email, password, confirm password. Client-side validation: required fields, email format, password strength, password confirmation match. Display appropriate error messages.",
          "status": "done"
        },
        {
          "id": 2,
          "title": "Create Login.svelte Component",
          "description": "Develop the `Login.svelte` component, including form inputs for user login (e.g., email, password) and implement client-side validation logic.",
          "dependencies": [],
          "details": "Form fields: email, password. Client-side validation: required fields, email format. Display appropriate error messages.",
          "status": "done"
        },
        {
          "id": 3,
          "title": "Implement API Communication for Auth Endpoints",
          "description": "Implement `fetch` API calls from the Svelte components (or a dedicated service) to interact with the backend `/auth/register` and `/auth/login` endpoints. Handle request submission and response processing.",
          "dependencies": [
            1,
            2
          ],
          "details": "Functions to call `/auth/register` with registration data and `/auth/login` with login credentials. Handle success responses (e.g., receiving a JWT) and error responses (e.g., displaying backend error messages).",
          "status": "done"
        },
        {
          "id": 4,
          "title": "Manage Client-Side Authentication State",
          "description": "Implement mechanisms for managing the client-side authentication state. This includes storing the JWT (e.g., in `localStorage` or `sessionStorage`) upon successful authentication and using Svelte stores to make the authentication status and user data globally accessible.",
          "dependencies": [
            3
          ],
          "details": "Create a Svelte store (e.g., `authStore.js`) to hold user object and token. Functions to save token to localStorage, load token from localStorage on app init, and clear token. Update store based on login/registration success.",
          "status": "done"
        },
        {
          "id": 5,
          "title": "Implement Logout and Conditional UI Rendering",
          "description": "Implement logout functionality that clears the authentication state (JWT from storage, Svelte store). Update the UI to render conditionally based on the user's authentication status (e.g., show user profile/logout vs. login/register links).",
          "dependencies": [
            4
          ],
          "details": "Create a logout function/button that clears the token from localStorage and resets the auth store. Implement route guards or conditional rendering in Svelte components (`{#if $authStore.isAuthenticated}`) to protect routes and show/hide UI elements.",
          "status": "done"
        }
      ]
    },
    {
      "id": 7,
      "title": "BE: Cryptocurrency Management API & Seed Data",
      "description": "Create backend API endpoints for managing simulated cryptocurrencies (e.g., list all, get details). Implement a Cryptocurrency model and database interactions. Seed the database with initial cryptocurrency data (e.g., SIM_BTC, SIM_ETH).",
      "details": "Create a `/cryptocurrencies` GET endpoint in Express to list all active cryptocurrencies from the `Cryptocurrencies` table. Implement model functions for `Cryptocurrency` (e.g., `getAllCryptocurrencies`). Create a seed script (SQL or Node.js) to populate `Cryptocurrencies` table with initial data like: `('SIM_BTC', 'Simulated Bitcoin', 'A simulated version of Bitcoin for trading practice', true)`, `('SIM_ETH', 'Simulated Ethereum', 'A simulated version of Ethereum', true)`.",
      "testStrategy": "API endpoint `/cryptocurrencies` returns a JSON array of seeded cryptocurrencies. Data should match what's in the database.",
      "priority": "medium",
      "dependencies": [
        2
      ],
      "status": "done",
      "subtasks": [
        {
          "id": 1,
          "title": "Define/Update Cryptocurrency Database Model",
          "description": "Create or update the data model/schema for cryptocurrencies. This includes defining fields such as ID, name, symbol, current_price, and any other relevant attributes for database storage and interaction.",
          "dependencies": [],
          "details": "Specify data types, constraints (e.g., unique, not null), and relationships for the Cryptocurrency entity. This model will be used by the API and seeding script. Ensure it aligns with requirements for listing active cryptocurrencies.",
          "status": "done"
        },
        {
          "id": 2,
          "title": "Implement GET /cryptocurrencies API Endpoint",
          "description": "Develop a GET API endpoint (e.g., `/api/cryptocurrencies`) that retrieves and returns a list of all active cryptocurrencies from the database. This endpoint will use the Cryptocurrency model defined in subtask 1.",
          "dependencies": [
            1
          ],
          "details": "The endpoint should interact with the database to fetch all records from the `Cryptocurrencies` table. Ensure it returns data in a standard JSON format. Implement logic to filter for 'active' cryptocurrencies if this is a requirement.",
          "status": "done"
        },
        {
          "id": 3,
          "title": "Develop Cryptocurrency Data Seeding Script",
          "description": "Create a script (e.g., SQL, Node.js, or using an ORM's seeding mechanism) to populate the `Cryptocurrencies` table with initial sample data. This data will be used for development and testing the API.",
          "dependencies": [
            1
          ],
          "details": "The script should insert a predefined list of common cryptocurrencies (e.g., Bitcoin, Ethereum, Litecoin) with their respective details into the database, adhering to the model/schema defined in subtask 1. Include data for fields like name, symbol, and an initial price.",
          "status": "done"
        }
      ]
    },
    {
      "id": 8,
      "title": "FE: Display Cryptocurrencies",
      "description": "Develop a Svelte component to fetch and display the list of available cryptocurrencies from the backend. This list will be used for users to select which market to view/trade.",
      "details": "Create a `CryptoList.svelte` component. In its `onMount` lifecycle function or a load function (SvelteKit), use `fetch` to GET data from the `/cryptocurrencies` backend endpoint. Display the symbols and names in a list or table. Allow selection of a cryptocurrency (this will be used later for trading views).",
      "testStrategy": "The frontend correctly fetches and displays the list of cryptocurrencies obtained from the backend API. Selection mechanism should be testable.",
      "priority": "medium",
      "dependencies": [
        5,
        7
      ],
      "status": "done",
      "subtasks": [
        {
          "id": 1,
          "title": "Create CryptocurrencyList component structure",
          "description": "Create a new Svelte component to display the list of cryptocurrencies with basic structure and imports.",
          "details": "",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 8
        },
        {
          "id": 2,
          "title": "Implement API fetch logic for cryptocurrencies",
          "description": "Add function to fetch cryptocurrency data from the backend /api/crypto/cryptocurrencies endpoint using fetch API.",
          "details": "",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 8
        },
        {
          "id": 3,
          "title": "Create UI template for cryptocurrency display",
          "description": "Design and implement the HTML template to display cryptocurrency list with proper styling and layout.",
          "details": "",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 8
        }
      ]
    },
    {
      "id": 9,
      "title": "BE: Account & CryptoHolding Models & Balance API",
      "description": "Implement backend models for `Accounts` (fiat) and `CryptoHoldings` (crypto). Create API endpoints for authenticated users to fetch their balances. Implement logic to seed initial simulated fiat (e.g., SIM_USD) and/or crypto balances for new users upon registration or first login.",
      "details": "Create `/account/balances` GET endpoint, protected by auth middleware. This endpoint should query `Accounts` and `CryptoHoldings` tables for the logged-in user (`req.user.id`). Return a consolidated list of balances. Implement logic (e.g., during user registration or a separate seeding function) to give new users a starting amount of 'SIM_USD' in their `Accounts` table and potentially some base simulated crypto in `CryptoHoldings`.",
      "testStrategy": "Authenticated users can fetch their balances via the API. New users should have default seeded balances. Balances should reflect database state.",
      "priority": "high",
      "dependencies": [
        2,
        4
      ],
      "status": "done",
      "subtasks": [
        {
          "id": 1,
          "title": "Implement Account and CryptoHolding Database Models & Services",
          "description": "Define database schemas and implement service layer logic for `Accounts` (fiat) and `CryptoHoldings` (crypto).",
          "dependencies": [],
          "details": "This includes defining all necessary fields, relationships, data types, and basic CRUD operations for both models. `Accounts` will manage fiat currency balances (e.g., SIM_USD), and `CryptoHoldings` will manage cryptocurrency balances.",
          "status": "done"
        },
        {
          "id": 2,
          "title": "Create Authenticated GET API for User Balances",
          "description": "Develop an authenticated GET API endpoint (e.g., `/account/balances`) to fetch combined fiat and crypto balances for the logged-in user.",
          "dependencies": [
            1
          ],
          "details": "The endpoint must integrate with the authentication system. It will query the `Accounts` and `CryptoHoldings` data, aggregating balances for the specific user making the request.",
          "status": "done"
        },
        {
          "id": 3,
          "title": "Implement New User Initial Balance Seeding Logic",
          "description": "Develop the backend logic to automatically seed initial fiat (e.g., SIM_USD) and/or crypto balances for new users upon successful registration.",
          "dependencies": [
            1
          ],
          "details": "This logic should be triggered during the user registration process. Specify the default amounts and types of currencies/cryptocurrencies to be credited to new user accounts.\n<info added on 2025-05-24T15:54:51.474Z>\nUpon new user registration, only an initial fiat balance (SIM_USD 10000.00) will be seeded into the 'accounts' table. No initial cryptocurrency balances will be seeded. The existing implementation in `server/routers/authRouter.js` correctly handles this fiat seeding.\n</info added on 2025-05-24T15:54:51.474Z>",
          "status": "done"
        },
        {
          "id": 4,
          "title": "Ensure Correct User ID Filtering in Balance API Queries",
          "description": "Implement and verify that all API queries for fetching balances correctly join and filter data by `user_id` to ensure data integrity and security.",
          "dependencies": [
            2
          ],
          "details": "This involves rigorous testing of the `/account/balances` endpoint to confirm that it only returns data belonging to the authenticated user, preventing any cross-user data exposure. Review query construction for `Accounts` and `CryptoHoldings`.",
          "status": "done"
        }
      ]
    },
    {
      "id": 10,
      "title": "FE: Display Account Balances",
      "description": "Create Svelte components to display the authenticated user's fiat and cryptocurrency balances, fetched from the backend API.",
      "details": "Create an `AccountDashboard.svelte` or similar component. When the component mounts and the user is authenticated, use `fetch` to GET data from `/account/balances`. Display the balances clearly, separating fiat and different cryptocurrencies.",
      "testStrategy": "Logged-in user sees their correct fiat and crypto balances displayed. If no balances, an appropriate message is shown. Updates if balances change (e.g., after a trade, to be tested later).",
      "priority": "high",
      "dependencies": [
        6,
        9
      ],
      "status": "done",
      "subtasks": [
        {
          "id": 1,
          "title": "Create Account Dashboard Component Shell",
          "description": "Develop the basic structure for the `AccountDashboard.svelte` component (or equivalent for the chosen frontend framework). This component will serve as the container for displaying account balances.",
          "dependencies": [],
          "details": "Focus on creating the file, basic HTML/Svelte structure, and any necessary initial styling placeholders. No data fetching or display logic at this stage.",
          "status": "done"
        },
        {
          "id": 2,
          "title": "Implement Balance Fetching Logic",
          "description": "Implement the client-side logic to make authenticated API calls to the backend to retrieve the user's fiat and crypto account balances. This includes handling API responses and errors.",
          "dependencies": [
            1
          ],
          "details": "This logic might reside within the `AccountDashboard.svelte` component (e.g., in its script section or a lifecycle function) or in a separate service/store that the component consumes. Ensure proper handling of authentication tokens and API error states (e.g., network issues, unauthorized).",
          "status": "done"
        },
        {
          "id": 3,
          "title": "Display Balances in UI with Edge Case Handling",
          "description": "Integrate the fetched balance data into the `AccountDashboard.svelte` component's template. Clearly display the various fiat and crypto balances, and implement UI to handle cases such as zero balances, non-existent balances (if applicable), loading states, and error states from fetching.",
          "dependencies": [
            1,
            2
          ],
          "details": "Consider formatting for currency and cryptocurrency values. Implement user-friendly messages for loading, errors, or when no balances are available. Ensure the UI is responsive and accessible.",
          "status": "done"
        }
      ]
    },
    {
      "id": 11,
      "title": "BE: Order & Trade Models & DB Schema",
      "description": "Define and implement database schema for `Orders` and `Trades` within the existing `createDb.js` script. `Orders` will store user's buy/sell orders. `Trades` will record executed transactions between users.",
      "status": "done",
      "dependencies": [
        2
      ],
      "priority": "high",
      "details": "Extend DB schema by defining `Orders` and `Trades` tables within `createDb.js`. `Orders` (order_id PK, user_id FK, cryptocurrency_id FK, type ('buy'/'sell'), order_type ('limit'/'market'), quantity_total DECIMAL, quantity_remaining DECIMAL, price DECIMAL, status ('open', 'partially_filled', 'fully_filled', 'cancelled'), created_at, updated_at). `Trades` (trade_id PK, buy_order_id FK, sell_order_id FK, cryptocurrency_id FK, quantity DECIMAL, price DECIMAL, buyer_user_id FK, seller_user_id FK, trade_timestamp). The `createDb.js` script will handle schema creation, dropping, and resetting; formal versioned migration tool integration is not planned for this task.",
      "testStrategy": "Verify `Orders` and `Trades` tables are created correctly in the database with all specified fields and constraints by running the `createDb.js` script. Ensure the script can successfully drop and recreate these tables.",
      "subtasks": []
    },
    {
      "id": 12,
      "title": "BE: Order Placement API (Limit Orders)",
      "description": "Implement a backend API endpoint for users to place new buy or sell orders, supporting both 'limit' and 'market' order types as per the updated request structure. This endpoint must validate the order through a 4-layer architecture (Input Validation, Business Rules Validation, Balance Validation, Error Handling) and, if valid, store it in the `Orders` table with an 'open' status. The request structure is { cryptocurrency_id, type, order_type, quantity, price (optional for market orders) }.",
      "status": "done",
      "dependencies": [
        4,
        9,
        11,
        "31",
        "32",
        "33"
      ],
      "priority": "high",
      "details": "Create `POST /orders` endpoint (as per REST conventions, protected by auth middleware). \nRequest body: `{ cryptocurrency_id: int, type: 'buy'/'sell', order_type: 'limit'/'market', quantity: float, price: float (required for 'limit' orders, optional for 'market' orders) }`.\n\nBackend Logic (4-Layer Validation Architecture):\n1.  **Layer 1: Input Validation (No Database Calls)**: Validate data types, required fields (price is conditional on `order_type`), and formats (e.g., positive numbers for quantity/price, valid enum values for type/order_type).\n2.  **Layer 2: Business Rules Validation (Lightweight DB Calls)**: Check `cryptocurrency_id` existence in the `cryptocurrencies` table. Basic validation of quantity/price (e.g. positive values, though primarily handled in Layer 1).\n3.  **Layer 3: Balance Validation (Critical Financial Check)**:\n    *   If 'buy' order: Check user's SIM_USD balance in the `accounts` table. For limit orders, ensure `balance >= quantity * price`. (Market order cost estimation for balance check needs separate clarification if fully implemented under this task).\n    *   If 'sell' order: Check user's relevant cryptocurrency balance in the `crypto_holdings_base` table, ensuring `crypto_balance >= quantity`.\n4.  **Order Creation**: If all validations pass, create a new record in the `Orders` table with status 'open', `quantity_remaining = quantity_total`, and include `order_type`.\n5.  **Layer 4: Error Handling & Response**: Respond with success or a standardized JSON error (using HTTP status codes like 400, 422, 500) providing detailed messages.",
      "testStrategy": "Authenticated users can submit valid limit and market orders. Orders are stored correctly in the DB, including `order_type` and appropriate `price` (null for market if not provided). \nLayer 1 Validations: Test rejections for invalid data types, missing required fields (e.g., price for limit order, or `order_type`), invalid enum values, non-positive quantity/price. \nLayer 2 Validations: Test rejections for non-existent `cryptocurrency_id`. \nLayer 3 Validations: Test rejections for insufficient SIM_USD (buy orders) or crypto (sell orders) balance. Verify correct tables (`accounts`, `crypto_holdings_base`) are checked. \nLayer 4 Validations: Ensure standardized JSON error responses with correct HTTP status codes (400, 422, 500) for all failure scenarios. Test successful order placement for both 'buy' and 'sell' types, and for 'limit' and 'market' order types.",
      "subtasks": [
        {
          "id": 1,
          "title": "Define POST /orders/ Endpoint and Basic Structure",
          "description": "Create the Express route for `POST /orders/`. Integrate existing authentication middleware to protect the endpoint. Set up the basic request handler structure within the appropriate Express router.",
          "dependencies": [],
          "details": "This involves: 1. Locating or creating the relevant Express router file (e.g., `orderRoutes.js`). 2. Defining the `POST /orders/` route, adhering to RESTful conventions. 3. Applying the project's standard authentication middleware to this route. 4. Creating an initial placeholder controller/handler function for this route.\n<info added on 2025-05-25T15:00:29.180Z>\nUsing RESTful POST /orders/ endpoint instead of /orders/place as this follows proper REST conventions. The basic structure is already in place in orderRouter.js with authentication middleware applied.\n</info added on 2025-05-25T15:00:29.180Z>",
          "status": "done"
        },
        {
          "id": 2,
          "title": "Implement Layer 1 & 2 Validation (Input & Business Rules)",
          "description": "Develop and integrate server-side validation for the order placement request body, covering Layer 1 (Input Validation - no DB calls) and Layer 2 (Business Rules Validation - lightweight DB calls). This includes `cryptocurrency_id`, `type`, `order_type`, `quantity`, and `price`.",
          "dependencies": [
            1
          ],
          "details": "This involves:\n**Layer 1: Input Validation (No Database Calls)**\n1.  Validate data types for all fields: `cryptocurrency_id` (integer), `type` (string), `order_type` (string), `quantity` (number), `price` (number, if present).\n2.  Validate required fields: `cryptocurrency_id`, `type`, `order_type`, `quantity` are always required.\n3.  Conditional `price` validation: `price` is required if `order_type` is 'limit'; optional if `order_type` is 'market'. If provided for market, it might be ignored or used as a ceiling, per system design.\n4.  Validate enum values: `type` must be 'buy' or 'sell'. `order_type` must be 'limit' or 'market'.\n5.  Validate numeric formats: `quantity` must be a positive number. `price` (if provided) must be a positive number. Adhere to any precision/min/max rules.\n\n**Layer 2: Business Rules Validation (Lightweight DB Calls)**\n1.  Validate `cryptocurrency_id`: Ensure it exists in the `cryptocurrencies` table.\n2.  Basic quantity/price validation (e.g., positive values) - primarily covered in Layer 1, re-verify if any DB-dependent rules apply here (e.g., lot sizes, tick sizes if defined).\n\nEnsure validation errors from both layers lead to appropriate early responses (e.g., HTTP 400 Bad Request or 422 Unprocessable Entity).",
          "status": "done"
        },
        {
          "id": 3,
          "title": "Implement Layer 3: Balance Validation",
          "description": "Create logic for Layer 3 (Balance Validation) to check the authenticated user's available balance. For 'buy' orders, check SIM_USD balance in the `accounts` table. For 'sell' orders, check the relevant cryptocurrency balance in the `crypto_holdings_base` table.",
          "dependencies": [
            2
          ],
          "details": "This involves:\n1.  Retrieving the authenticated user's ID (from the auth middleware).\n2.  For 'buy' orders:\n    a.  Query the `accounts` table for the user's available SIM_USD balance.\n    b.  If `order_type` is 'limit', ensure `available_SIM_USD_balance >= quantity * price`.\n    c.  If `order_type` is 'market', the mechanism for determining the funds to hold (e.g., based on quantity and current market price or a buffer) needs to be defined. For this task, prioritize limit order logic.\n3.  For 'sell' orders:\n    a.  Query the `crypto_holdings_base` table for the user's available balance of the specified `cryptocurrency_id`.\n    b.  Ensure `available_crypto_balance >= quantity`.\n4.  Ensure the balance check considers only *available* funds (e.g., not funds locked in other open orders).\n5.  This logic is critical and should be callable from the order placement handler after Layer 1 and Layer 2 validations pass. If balance is insufficient, respond with an appropriate error (e.g., HTTP 400 or 422).",
          "status": "done"
        },
        {
          "id": 4,
          "title": "Implement Order Creation in PostgreSQL Database",
          "description": "If all validations (Layers 1-3) pass and the user has sufficient funds, implement the logic to create a new order record in the `Orders` table in the PostgreSQL database with an initial status of 'open'. Include `order_type` in the stored record.",
          "dependencies": [
            3
          ],
          "details": "This involves:\n1.  Constructing the data object for the new order, including `user_id`, `cryptocurrency_id`, `type` (buy/sell), `order_type` (limit/market), `quantity_total` (from request `quantity`), `price` (from request `price` for limit orders; can be null for market orders if not provided or not applicable at creation), `status` ('open'), and `quantity_remaining` (initially equal to `quantity_total`), `created_at` (timestamp).\n2.  Using the project's database access layer (e.g., ORM, query builder, or raw SQL client) to insert the new record into the `Orders` table.\n3.  Ensure the operation is robust. Consider if this operation should be part of a larger transaction if funds are to be locked/deducted simultaneously (though fund movement might be handled by a separate ledger service or subsequent step).",
          "status": "done"
        },
        {
          "id": 5,
          "title": "Implement Layer 4: Error Handling and Response Formatting",
          "description": "Ensure robust error handling throughout the order placement process as per Layer 4. Provide clear, standardized JSON error responses for various failure scenarios, using appropriate HTTP status codes (e.g., 400, 422, 500).",
          "dependencies": [
            2,
            3,
            4
          ],
          "details": "This involves:\n1.  Defining or adhering to a project-wide standardized JSON error response format (e.g., `{ \"error\": { \"message\": \"...\", \"code\": \"...\" } }`).\n2.  Handling errors from Layer 1 & 2 (Input and Business Rule Validation) with HTTP 400 (Bad Request) or HTTP 422 (Unprocessable Entity) for client-side errors. Include detailed messages indicating which field or rule failed.\n3.  Handling errors from Layer 3 (Balance Validation - e.g., insufficient funds) with an appropriate HTTP status (e.g., HTTP 400 or 422), with a clear message.\n4.  Handling potential errors during database interaction (Order Creation in Subtask 4) with HTTP 500 (Internal Server Error) for unexpected server-side issues.\n5.  Ensuring all success responses (e.g., HTTP 201 Created for new order) also follow a consistent format, returning relevant information about the created order.",
          "status": "done"
        }
      ]
    },
    {
      "id": 13,
      "title": "FE: Trading Form & My Open Orders Display",
      "description": "Develop Svelte components for a trading form (select crypto, buy/sell, quantity, price) and a display area for the user's currently open orders. Orders submitted via the form should be sent to the backend API.",
      "details": "Create `TradingForm.svelte` component. Inputs for cryptocurrency selection (dropdown populated from crypto list), order type (buy/sell buttons), quantity, price. On submit, `fetch` POST to `/orders/place`. Create `MyOpenOrders.svelte` component. Fetch user's open orders from a new backend endpoint (e.g., `/orders/mine`) and display them in a table.",
      "testStrategy": "User can fill and submit the trading form. Order data is sent to backend. User's open orders are fetched and displayed correctly. Client-side validation for form inputs.",
      "priority": "high",
      "dependencies": [
        6,
        8,
        10,
        12,
        "31",
        "32",
        "33"
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 14,
      "title": "BE: WebSocket Server Integration",
      "description": "Integrate a WebSocket server (e.g., `ws` library or `socket.io`) into the Express backend. Handle basic client connections and disconnections.",
      "details": "Install `ws` (`npm install ws`). Integrate with existing HTTP server: `const WebSocket = require('ws'); const server = http.createServer(app); const wss = new WebSocket.Server({ server }); wss.on('connection', ws => { console.log('Client connected'); ws.on('message', message => console.log('received: %s', message)); ws.on('close', () => console.log('Client disconnected')); }); server.listen(PORT, ...);`. This sets up the WebSocket server alongside Express.",
      "testStrategy": "WebSocket server starts with the HTTP server. Client can connect to the WebSocket endpoint. Connection/disconnection events are logged on the server.",
      "priority": "high",
      "dependencies": [
        1
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 15,
      "title": "FE: WebSocket Client Integration",
      "description": "Implement Socket.IO client logic in the Svelte frontend to connect to the backend Socket.IO server. Handle connection establishment and receive 'orderBookUpdate' events containing Binance market data.",
      "status": "done",
      "dependencies": [
        5,
        14
      ],
      "priority": "high",
      "details": "Integrate the Socket.IO client library (`socket.io-client`) into the Svelte frontend. In a Svelte store or a suitable client-side component (e.g., `+layout.svelte` or a dedicated service), establish a Socket.IO connection: `import { io } from 'socket.io-client'; const socket = io('http://localhost:8080'); socket.on('connect', () => console.log('Connected to Socket.IO server')); socket.on('disconnect', () => console.log('Disconnected from Socket.IO server')); socket.on('orderBookUpdate', (data) => console.log('Order book update:', data));`. Ensure this runs client-side. The backend already logs user connections/disconnections, so frontend logging for these events is primarily for client-side debugging.",
      "testStrategy": "Svelte frontend successfully connects to the backend Socket.IO server at 'http://localhost:8080'. Console logs confirm connection. Verify that 'orderBookUpdate' events are received and that the payload contains Binance market data. Backend logs should also show client connection/disconnection.",
      "subtasks": [
        {
          "id": 1,
          "title": "Install socket.io-client library",
          "description": "Install the socket.io-client library in the frontend project to enable Socket.IO communication.",
          "details": "",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 15
        },
        {
          "id": 2,
          "title": "Create Socket.IO store structure",
          "description": "Create socketStore.js with writable stores for socket connection, connection status, and order book data. Include connectSocket and disconnectSocket functions.",
          "details": "",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 15
        },
        {
          "id": 3,
          "title": "Implement connection and disconnect event listeners",
          "description": "Add event listeners for 'connect' and 'disconnect' events, logging connection status to the browser console and updating the isConnected store.",
          "details": "",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 15
        },
        {
          "id": 4,
          "title": "Implement orderBookUpdate event listener",
          "description": "Add event listener for 'orderBookUpdate' events, logging the received Binance market data to the browser console and updating the orderBookData store.",
          "details": "",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 15
        }
      ]
    },
    {
      "id": 16,
      "title": "BE: In-Memory Order Book Implementation",
      "description": "Develop a trading simulation engine that uses Binance WebSocket data as a price oracle. The implementation will be phased: Phase 1 focuses on basic market order execution against Binance's best bid/ask, trade recording, and notifications. Phase 2 introduces handling of order book depth for market orders, implements limit order execution logic, and enhances data structures. Phase 3 will focus on visualizing the impact of user trades on a representation of the Binance order book. This system simulates trading against Binance prices, without implementing user-to-user matching or a complex hybrid order book. The `binance-ws.js` module will be the primary component for Binance integration.",
      "status": "in-progress",
      "dependencies": [
        11,
        12
      ],
      "priority": "high",
      "details": "The project is divided into three phases:\n\n**Phase 1: Basic Trading Engine (Target: 15-20 hours)**\n1.  **Binance Price Oracle Integration:**\n    *   Extend `binance-ws.js` to subscribe to Binance's ticker or best bid/ask streams (e.g., `symbol@bookTicker`).\n    *   Maintain a real-time local cache of the current best bid and ask prices from Binance for simulated trading pairs.\n2.  **Market Order Execution (Basic):**\n    *   Implement logic to accept user market orders (buy/sell).\n    *   Market orders execute *immediately* at the currently cached best bid (for sells) or best ask (for buys) from Binance.\n    *   Assume sufficient liquidity at the best bid/ask for simplicity in this phase.\n3.  **Trade Recording:**\n    *   Store executed trades in a database, including details like pair, side (buy/sell), quantity, execution price, timestamp, and user ID.\n4.  **Basic WebSocket Notifications:**\n    *   Implement basic WebSocket notifications to users upon trade execution (e.g., order filled).\n\n**Phase 2: Add Depth & Sophistication (Target: +10-15 hours)**\n1.  **Binance Order Book Depth Integration:**\n    *   Enhance `binance-ws.js` to subscribe to Binance's full or partial depth WebSocket streams (e.g., `symbol@depth5`, `symbol@depth@100ms`).\n    *   Maintain a local, synchronized copy of the relevant levels of the Binance order book (bids and asks).\n2.  **Market Order Execution (Depth-Aware):**\n    *   Modify market order execution logic to \"walk the book\". If an order's quantity exceeds liquidity at the best price, it consumes subsequent price levels from the local Binance order book copy until filled.\n    *   Calculate the volume-weighted average price (VWAP) for such executions.\n3.  **Limit Order Implementation:**\n    *   Implement logic to accept user limit orders (buy/sell) with a specified price and quantity.\n    *   Store pending limit orders.\n    *   Continuously monitor the live Binance price stream (best bid/ask or depth).\n    *   Execute limit orders when the market price reaches the order's limit price.\n4.  **Enhanced Order Management:**\n    *   Implement order status updates (pending, partially_filled, filled, cancelled).\n    *   Allow users to cancel pending limit orders.\n\n**Phase 3: Visual Order Book Magic (Target: +20-25 hours)**\n1.  **Simulated Order Book State:**\n    *   Develop data structures to represent a *simulated* view of the Binance order book that reflects the *impact* of user trades within the simulation.\n    *   When a user trade \"consumes\" liquidity from a Binance price level, this simulated view should show reduced quantity at that level for that user's perspective.\n2.  **Real-time Order Book Display Logic:**\n    *   Implement backend logic to provide data for a UI to display this simulated order book.\n    *   The display should update in real-time as Binance prices change and as user trades \"consume\" liquidity.\n3.  **Visual Feedback of Market Consumption:**\n    *   Ensure the simulated order book clearly visualizes how user market orders \"eat through\" Binance liquidity levels. This is a personalized visual representation of *their* impact and does not affect other users' execution prices.",
      "testStrategy": "**Phase 1 Tests:**\n1.  Verify `binance-ws.js` correctly subscribes to and caches Binance best bid/ask prices.\n2.  Test market order placement: ensure they execute immediately at the correct current Binance best bid/ask.\n3.  Verify trade details (price, quantity, side, timestamp) are correctly recorded in the database.\n4.  Test WebSocket notifications for trade executions.\n\n**Phase 2 Tests:**\n1.  Verify `binance-ws.js` correctly synchronizes with Binance depth streams, maintaining an accurate local copy of order book levels.\n2.  Test depth-aware market order execution:\n    a. Orders smaller than best level liquidity fill at best price.\n    b. Orders larger than best level liquidity walk the book and fill at multiple levels, with correct VWAP.\n    c. Handle partial fills if order quantity exceeds available simulated depth.\n3.  Test limit order placement: ensure they are stored as pending.\n4.  Test limit order execution:\n    a. Buy limit orders trigger when Binance ask price reaches or drops below the limit.\n    b. Sell limit orders trigger when Binance bid price reaches or rises above the limit.\n    c. Verify execution against appropriate book depth if needed.\n5.  Test cancellation of pending limit orders.\n6.  Verify order status updates (pending, filled, partially_filled, cancelled) are accurate.\n\n**Phase 3 Tests:**\n1.  Verify the simulated order book data structure correctly initializes with live Binance data.\n2.  Test that after a user's simulated market order executes, the corresponding quantities in the *simulated* order book view are reduced accordingly for that user's perspective.\n3.  Test that the simulated order book updates in real-time based on incoming Binance price level changes.\n4.  Ensure the data provided for UI display accurately reflects the \"consumed\" liquidity from user trades.\n5.  Confirm that one user's simulated consumption does not alter the execution prices for other users (who still trade against the live Binance book).",
      "subtasks": [
        {
          "id": 1,
          "title": "Phase 1: Setup Binance Price Oracle (`binance-ws.js` extension)",
          "description": "Extend `binance-ws.js` to subscribe to Binance's ticker or best bid/ask streams (e.g., `symbol@bookTicker`) and maintain a real-time local cache of current best bid/ask prices.",
          "details": "Focus on efficient subscription and reliable caching of best bid/ask for multiple trading pairs. This forms the basis for Phase 1 executions.\n<info added on 2025-06-01T17:05:45.354Z>\nCLARIFICATION NEEDED: Before proceeding with implementation, need to confirm architecture approach with user.\nCURRENT UNDERSTANDING (from Task 16):\n- This is NOT a traditional user-to-user order book\n- This IS a trading simulation against Binance liquidity\n- Users trade against Binance prices (Binance as counterparty)\n- Visual order book shows Binance data with consumption feedback\n- Three phases: Basic execution → Depth-aware → Visual impact\nQUESTION FOR USER: Confirm this Binance-simulation approach vs traditional order matching before continuing implementation.\n</info added on 2025-06-01T17:05:45.354Z>",
          "dependencies": [],
          "status": "done"
        },
        {
          "id": 2,
          "title": "Phase 1: Implement Basic Market Order Execution",
          "description": "Implement logic for user market orders (buy/sell) to execute immediately at the cached Binance best bid/ask. Assume sufficient liquidity at this price level for Phase 1.",
          "details": "Handle order requests, use cached prices from subtask 1 for execution. Calculate execution price and filled quantity. This is a simplified execution model.",
          "dependencies": [
            1
          ],
          "status": "done"
        },
        {
          "id": 3,
          "title": "Phase 1: Implement Trade Recording & Basic Notifications",
          "description": "Store executed trades from subtask 2 in a database. Implement basic WebSocket notifications to users upon trade execution.",
          "details": "Database schema for trades (pair, side, quantity, price, timestamp, user_id). Simple WebSocket message for 'order filled' status.",
          "dependencies": [
            2
          ],
          "status": "done"
        },
        {
          "id": 4,
          "title": "Phase 2: Binance Order Book Depth Integration (`binance-ws.js` enhancement)",
          "description": "Enhance `binance-ws.js` to subscribe to Binance's depth WebSocket streams (e.g., `symbol@depth5` or `symbol@depth@100ms`) and maintain a local, synchronized copy of Binance order book levels.",
          "details": "Handle initial snapshot and differential updates for depth streams. Ensure data structures for local Binance book are efficient for updates and reads by the execution engine.",
          "dependencies": [
            1
          ],
          "status": "pending"
        },
        {
          "id": 5,
          "title": "Phase 2: Implement Depth-Aware Market Order Execution",
          "description": "Modify market order execution to 'walk the book'. If an order's quantity exceeds liquidity at one price level, it consumes subsequent levels from the local Binance order book copy until filled or liquidity exhausted. Calculate VWAP.",
          "details": "Use depth data from subtask 4. Handle partial fills if order quantity exceeds available simulated depth. Calculate Volume-Weighted Average Price for multi-level fills.",
          "dependencies": [
            2,
            4
          ],
          "status": "pending"
        },
        {
          "id": 6,
          "title": "Phase 2: Implement Limit Order Logic",
          "description": "Implement placement of user limit orders (buy/sell). Monitor the live Binance price stream (best bid/ask or depth) and execute limit orders when market conditions meet order criteria, potentially walking the book.",
          "details": "Store pending limit orders. Logic to check trigger conditions (e.g., Binance best ask <= limit buy price). Execution may consume multiple depth levels similar to market orders (subtask 5).",
          "dependencies": [
            2,
            4
          ],
          "status": "pending"
        },
        {
          "id": 7,
          "title": "Phase 2: Implement Order Management (Status, Cancellation)",
          "description": "Implement comprehensive order status updates (e.g., pending, partially_filled, filled, cancelled). Allow users to cancel their pending limit orders.",
          "details": "Update order state throughout its lifecycle. Ensure cancellations correctly remove orders from active consideration. Handle partial fills for both market (subtask 5) and limit orders (subtask 6).",
          "dependencies": [
            6
          ],
          "status": "pending"
        },
        {
          "id": 8,
          "title": "Phase 3: Design & Implement Simulated Order Book State for Visual Impact",
          "description": "Develop data structures and server-side logic to maintain a *simulated* view of the Binance order book. This view should reflect the *impact* of the current user's trades by showing reduced quantities at price levels they 'consumed'.",
          "details": "This is not for matching, but for user-specific visual feedback. Initialize from live Binance data (subtask 4). Update based on user's executed trades (subtasks 5, 6). This state is transient or user-session specific.",
          "dependencies": [
            4,
            5,
            6
          ],
          "status": "pending"
        },
        {
          "id": 9,
          "title": "Phase 3: Backend for Real-time Visual Order Book Display",
          "description": "Implement backend API endpoints or WebSocket messages to provide data for a UI to display the simulated order book (from subtask 8). This should show market consumption in real-time.",
          "details": "Expose the simulated order book state. Ensure data can be pushed or polled for real-time UI updates, reflecting both Binance market changes and the user's simulated trade impacts.",
          "dependencies": [
            8
          ],
          "status": "pending"
        }
      ]
    },
    {
      "id": 17,
      "title": "BE: Order Matching Engine Development",
      "description": "Develop the backend logic for a simplified order execution engine, as outlined in the task titled 'BE: Order Matching Engine Development'. This engine will **not** perform traditional user-to-user order matching. Instead, it will focus on executing user orders directly against Binance, using Binance as the price oracle and sole counterparty.\n\nKey functionalities include:\n1.  Executing user market orders immediately against cached Binance best bid/ask prices.\n2.  Handling user limit orders: monitoring against Binance prices and executing against Binance when triggered.\n3.  Implementing robust order validation (e.g., valid parameters, minimums) and user balance checks prior to execution.\n4.  Processing all trades with Binance as the designated counterparty.\n5.  Managing comprehensive order status updates (e.g., pending, active, partially_filled, filled, cancelled) and detailed trade recording.\n6.  Providing backend support for visual feedback on the consumption of Binance liquidity levels during order execution.\n\nThe implementation will follow a phased approach:\n*   **Phase 1:** Simple execution against cached Binance best bid/ask prices.\n*   **Phase 2:** Depth-aware execution, 'walking the book' using Binance order book levels if an order's size exceeds top-of-book liquidity.\n*   **Phase 3:** Enhanced support for visual feedback of liquidity consumption.\n\nIntegration with `binance-ws.js` is crucial for accessing real-time Binance market data. This system is fundamentally a Binance execution simulator/interface, not an independent matching venue.",
      "status": "pending",
      "dependencies": [
        16
      ],
      "priority": "high",
      "details": "To be implemented in `OrderBookService.js` or a dedicated `BinanceExecutionEngine.js` (or similar, reflecting its role as an execution interface with Binance rather than a traditional matching engine).\nThe execution logic will process user orders directly against Binance liquidity, with Binance acting as the sole counterparty.\n\n**Core Requirements:**\n*   **Order Validation & Balance Checks:** Before attempting execution, validate order parameters (e.g., symbol, side, type, quantity, price for limit orders) and confirm sufficient user balance.\n*   **Binance as Counterparty:** All trades are executed against Binance. No internal order book or user-to-user matching occurs.\n*   **Order Status Management & Trade Recording:** Maintain accurate order statuses throughout their lifecycle and record all trade executions.\n\n**Order Types Handled (Executed against Binance):**\n*   **Market Orders:** Executed immediately against the current Binance order book prices.\n*   **Limit Orders:** Placed and monitored; executed against Binance when the market price on Binance reaches the order's limit price.\n\n**Execution Process (Phased Implementation against Binance):**\n\n1.  **Phase 1: Simple Execution (Top-of-Book against Binance)**\n    *   For market orders: Execute against the best available bid (for sells) or ask (for buys) from the cached Binance order book.\n    *   For limit orders: Monitor against Binance best bid/ask. Trigger for execution if the limit price is marketable against Binance prices.\n    *   Execution is based on the single best price level from Binance.\n\n2.  **Phase 2: Depth-Aware Execution (\"Walking the Binance Book\")**\n    *   For market orders and triggered limit orders: If the order quantity exceeds liquidity at the best Binance price level, the engine will simulate \"walking the Binance book,\" consuming liquidity from subsequent price levels on Binance until the order is filled or available Binance depth is exhausted.\n    *   Calculates an average fill price if multiple Binance levels are consumed.\n\n**Fill Logic (against Binance):**\n*   Determine fill quantity based on available Binance liquidity at the matched price level(s).\n*   Handle partial fills: Update the remaining quantity of the user order. If a market order is partially filled due to insufficient Binance depth, the remainder might be cancelled or handled based on policy. If a limit order, the remaining part stays active against Binance.\n*   Handle full fills: Mark the user order as completed.\n*   Generate trade execution records for each fill (with Binance as counterparty).\n\n**Binance Integration:**\n*   Utilize real-time Binance order book data (best bid/ask and depth) provided by `binance-ws.js`.\n*   All executions are simulated against Binance liquidity at Binance prices.\n\n**Phase 3 Support:**\n*   The engine will be designed to provide necessary data points to support visual feedback of **Binance liquidity consumption** during the execution process.",
      "testStrategy": "Test various scenarios, ensuring all executions are simulated against Binance as the counterparty:\n1.  **Order Validation & Balance Checks:**\n    *   Test orders with invalid parameters (e.g., incorrect symbol, negative quantity).\n    *   Test orders where user balance is insufficient.\n    *   Verify orders are rejected appropriately before attempting execution.\n2.  **Market Order Execution (Phase 1 - Top of Book against Binance):**\n    *   New buy market order matching Binance best ask.\n    *   New sell market order matching Binance best bid.\n    *   Verify execution at Binance prices and correct fill quantity for orders smaller than or equal to liquidity at Binance's best price.\n3.  **Limit Order Management & Execution (against Binance):**\n    *   Limit buy order triggers when Binance ask price drops to or below limit price.\n    *   Limit sell order triggers when Binance bid price rises to or above limit price.\n    *   Test orders that don't match immediately and are correctly monitored against Binance prices.\n    *   Verify execution at limit price or better (simulating price improvement from Binance).\n    *   Test limit orders partially filling against Binance and remaining active.\n4.  **Market Order Execution (Phase 2 - Depth-Aware \"Walking the Binance Book\")**:\n    *   Market order larger than Binance's best price level liquidity, correctly consuming multiple depth levels from Binance.\n    *   Verify correct calculation of average fill price when multiple Binance levels are hit.\n    *   Test scenarios where order quantity exceeds total available Binance depth.\n5.  **Triggered Limit Order Execution (Phase 2 - Depth-Aware against Binance):**\n    *   Triggered limit order larger than Binance's best price level liquidity, correctly consuming multiple depth levels from Binance up to its limit price.\n    *   Verify correct fill quantities and average price if applicable.\n6.  **Fill Logic & Order State Management (with Binance as Counterparty):**\n    *   Test partial fills for both market and limit orders, ensuring remaining quantity is correct.\n    *   Test full fills, ensuring order status is updated to completed.\n    *   Verify correct generation of trade execution records (with Binance as counterparty).\n7.  **Integration & Data Integrity:**\n    *   Verify correct interaction with `binance-ws.js` for fetching and using Binance order book data.\n    *   Ensure order states (e.g., pending, active, partially_filled, filled, cancelled) are correctly managed and updated throughout the lifecycle.\n8.  **Visual Feedback Support:**\n    *   Verify backend provides necessary data points for visualizing Binance liquidity consumption.",
      "subtasks": [
        {
          "id": "subtask_17_1",
          "title": "Design overall architecture for the simplified Binance execution engine",
          "status": "pending",
          "description": "Define the high-level design, data flow, components (e.g., `BinanceExecutionEngine.js` or similar), and interaction with `binance-ws.js` for simulating order execution against Binance."
        },
        {
          "id": "subtask_17_2",
          "title": "Implement core data structures for user orders and cached Binance market data",
          "status": "pending",
          "description": "Develop structures for storing active user limit orders, tracking market orders, and representing cached Binance best bid/ask and order book depth levels for execution simulation."
        },
        {
          "id": "subtask_17_3",
          "title": "Enhance `binance-ws.js` integration for robust Binance market data acquisition",
          "status": "pending",
          "description": "Ensure the execution engine has reliable access to real-time best bid/ask prices and order book depth from Binance, with appropriate caching mechanisms, for accurate execution simulation."
        },
        {
          "id": "subtask_17_4",
          "title": "Implement Phase 1: Simple market order execution against cached Binance best bid/ask",
          "status": "pending",
          "description": "Develop the logic for executing user market orders using only the top-of-the-book data from Binance. Handle immediate fills based on available Binance liquidity at the best price."
        },
        {
          "id": "subtask_17_5",
          "title": "Implement limit order management: placement, monitoring against Binance prices, and triggering for execution against Binance",
          "status": "pending",
          "description": "Develop logic for accepting user limit orders, storing them, continuously monitoring Binance market prices, and triggering them for execution against Binance liquidity when conditions are met."
        },
        {
          "id": "subtask_17_6",
          "title": "Implement Phase 2: Depth-aware execution (\"walking the Binance book\")",
          "status": "pending",
          "description": "Enhance execution logic to consume multiple levels of the Binance order book depth if an order cannot be fully filled at the best price or a triggered limit order can fill across levels up to its limit price, simulating interaction with Binance's full depth."
        },
        {
          "id": "subtask_17_7",
          "title": "Implement fill processing: partial/full fills, status updates, trade recording (Binance as counterparty)",
          "status": "pending",
          "description": "Develop robust logic to handle the results of execution attempts against Binance, including calculating fill amounts, updating order statuses (e.g., active, partially_filled, filled), and generating events/records for confirmed trades with Binance as the counterparty."
        },
        {
          "id": "subtask_17_8",
          "title": "Implement BE support for Phase 3: Visual feedback of Binance liquidity consumption",
          "status": "pending",
          "description": "Specify and implement mechanisms for the backend to provide data points (e.g., consumed Binance depth levels, fill progression) that can be used by a UI to visualize how an order interacts with Binance market liquidity."
        },
        {
          "id": "subtask_17_9",
          "title": "Implement pre-execution order validation and balance checks",
          "status": "pending",
          "description": "Develop logic to perform order validation (e.g., symbol, side, type, quantity, price constraints) and user balance verification before any execution attempt against Binance is made. Ensure appropriate error handling for invalid orders or insufficient funds."
        }
      ]
    },
    {
      "id": 18,
      "title": "BE: Trade Execution & State Updates",
      "description": "Implement the backend logic for trade execution. All trades are user executions against Binance, which acts as the sole counterparty, price oracle, and liquidity provider. This system processes matched limit orders (from Task 17) and market orders directly against Binance. There are no user-to-user settlements. The system must atomically update only the user's balances, create a `Trade` record with Binance (via a system account) as the counterparty, and update the user's `Order` record (status, quantity) in the database and in-memory order book. Market orders require execution at simulated Binance prices with pre-trade balance validation. Atomicity of database operations is critical.",
      "status": "pending",
      "dependencies": [
        9,
        11,
        17
      ],
      "priority": "high",
      "details": "The core responsibility is to process user trades exclusively against Binance liquidity. This involves atomic database updates for the user's balances, trade record creation (with Binance as counterparty), and order status management. Market order execution at simulated Binance prices with balance validation is a key feature.\n\n**Key Requirements:**\n1.  **Binance as Sole Counterparty:** All trades are user orders filled against Binance liquidity. No user-to-user settlements.\n2.  **User-Only Balance Updates:** The system updates only the participating user's currency and asset balances. Binance's side is represented by a system account in trade records.\n3.  **Trade Record:** A `Trade` record is created for every execution, with `buyer_id` or `seller_id` being the user, and the other being a designated system account ID for Binance. Include `trade_type`='EXTERNAL_LIQUIDITY_TRADE'.\n4.  **Atomic Database Operations:** All database changes for a trade (user balance updates, trade creation, order updates) must be within a single transaction.\n5.  **Order Status Management:** User's `Order` records (status, quantity remaining) are updated in the database and reflected in the in-memory order book.\n6.  **Market Order Execution:** Support market orders executed at simulated Binance prices. This includes:\n    *   Fetching/determining the current execution price (simulated).\n    *   Pre-execution validation of user's available balance (quote currency for buy, base asset for sell).\n\n**Detailed Process:**\n\n**I. Pre-Execution & Validation:**\n    1.  Receive trade execution request:\n        *   For limit orders: From matching engine (Task 17) with matched price and quantity.\n        *   For market orders: Direct request with asset and quantity (or total quote value for buy).\n    2.  For market orders:\n        *   Fetch current simulated execution price from a Binance price feed/oracle.\n        *   Perform balance validation:\n            *   Buy: Ensure user has sufficient quote currency (`price * quantity`).\n            *   Sell: Ensure user has sufficient base asset (`quantity`).\n        *   If validation fails, reject the order and notify the user.\n    3.  Start a database transaction.\n\n**II. Trade Execution Logic (User vs. Binance):**\n    1.  **Identify User and Trade Details:** User ID, asset, quantity, price (fixed for limit, fetched for market).\n    2.  **Update User Balances (Atomically):**\n        *   **If user is BUYING base asset:**\n            *   Debit user's quote currency account by `price * quantity`.\n            *   Credit user's base currency holdings by `quantity`.\n        *   **If user is SELLING base asset:**\n            *   Credit user's quote currency account by `price * quantity`.\n            *   Debit user's base currency holdings by `quantity`.\n    3.  **Persist Balance Changes:** Save updates to user's `Accounts` and `CryptoHoldings` tables.\n    4.  **Create Trade Record:** Insert a new record into the `Trades` table:\n        *   `buyer_id`: User's ID if buying, Binance system account ID if user is selling.\n        *   `seller_id`: User's ID if selling, Binance system account ID if user is buying.\n        *   `crypto_id`, `quantity`, `price`, `timestamp`, `trade_type` ('EXTERNAL_LIQUIDITY_TRADE').\n    5.  **Update Order Record (Database & In-Memory):**\n        *   For limit orders: Update status (e.g., 'PARTIALLY_FILLED', 'FILLED'), decrease `quantity_remaining`.\n        *   For market orders: Mark the corresponding (transient or persisted) order as 'FILLED'.\n        *   Reflect changes in the in-memory order book if applicable (for limit orders).\n\n**III. Post-Execution:**\n    1.  **Commit Transaction:** If all operations succeed.\n    2.  **Rollback on Failure:** If any operation fails (including balance validation if part of the transaction).\n    3.  **Event Emission:** Emit events like `TradeExecuted`, `BalanceUpdated`, `OrderUpdated`.",
      "testStrategy": "The test strategy must cover trade execution against Binance as the sole counterparty, including market order specifics.\n\n1.  **Trade Execution Verification (User vs. Binance):**\n    *   **User Buys Base Asset (Limit/Market):**\n        *   Verify user's quote currency debited, base currency credited.\n        *   Verify `Trade` record: user as `buyer_id`, Binance system account as `seller_id`, `trade_type`='EXTERNAL_LIQUIDITY_TRADE', correct details.\n    *   **User Sells Base Asset (Limit/Market):**\n        *   Verify user's quote currency credited, base currency debited.\n        *   Verify `Trade` record: user as `seller_id`, Binance system account as `buyer_id`, `trade_type`='EXTERNAL_LIQUIDITY_TRADE', correct details.\n    *   For both:\n        *   Verify `Order` status and `quantity_remaining` updated in DB and in-memory (for limit orders).\n        *   Verify market orders are marked 'FILLED'.\n2.  **Market Order Specific Tests:**\n    *   **Balance Validation:**\n        *   Market Buy: Test execution with sufficient quote currency; test rejection if insufficient.\n        *   Market Sell: Test execution with sufficient base currency; test rejection if insufficient.\n    *   **Price Simulation:** Verify trades use the simulated Binance price for market orders.\n3.  **Atomicity Tests:**\n    *   Simulate failures during trade execution (e.g., post-debit, pre-credit; pre-trade record).\n    *   Verify transaction rollback and consistent system state.\n4.  **Concurrency Tests:**\n    *   Test concurrent limit and market order executions for data integrity (balances, order states).\n5.  **Edge Cases:**\n    *   Partial fills (limit orders).\n    *   Trades with very small/large quantities/prices.\n    *   Market orders consuming exactly available balance.",
      "subtasks": [
        {
          "id": "18_S1",
          "title": "Define/Update `Trades` table schema to represent Binance as the sole counterparty (e.g., using a designated system account ID) and include `trade_type` (e.g., 'EXTERNAL_LIQUIDITY_TRADE').",
          "status": "pending"
        },
        {
          "id": "18_S2",
          "title": "Implement the trade execution service entry point to handle matched limit orders (from Task 17) and incoming market order requests.",
          "status": "pending"
        },
        {
          "id": "18_S3",
          "title": "Implement core trade execution logic: atomically update only the user's balances, create `Trade` record (user vs. Binance system account), update user's `Order` record (DB & in-memory, if applicable).",
          "status": "pending"
        },
        {
          "id": "18_S4",
          "title": "Implement robust database transaction management for all trade execution operations to ensure atomicity.",
          "status": "pending"
        },
        {
          "id": "18_S5",
          "title": "Implement event emission (e.g., `TradeExecuted`, `BalanceUpdated`, `OrderUpdated`) upon successful trade execution.",
          "status": "pending"
        },
        {
          "id": "18_S6",
          "title": "Implement market order processing: fetch simulated Binance prices, perform pre-execution user balance validation, and integrate with trade execution logic.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 19,
      "title": "BE: Real-time Order Book Broadcasting",
      "description": "Implement a simplified real-time broadcasting system via WebSockets, focusing exclusively on Binance market data and individual user trading activity against the Binance order book. This system replaces any previous plans for user-to-user trade broadcasting. The system will:\n1. Broadcast live Binance order book data to all subscribed clients for visualization.\n2. Send user-specific trade notifications for trades executed against the Binance order book.\n3. Broadcast balance updates to individual users resulting from their trading activity or account changes.\n4. Provide visual feedback messages for user trades, indicating consumed liquidity from the Binance order book.\nThis approach emphasizes clean WebSocket messaging, direct streaming of Binance data, and providing users with clear feedback on their interactions with the Binance market, ensuring a simple and maintainable architecture.",
      "status": "pending",
      "dependencies": [
        14,
        16,
        18
      ],
      "priority": "high",
      "details": "The system will provide the following functionalities through WebSockets:\n\n1.  **Live Binance Order Book Broadcasting:**\n    *   Integrate with the Binance order book data stream (from Task 18: BE: Binance Order Book Integration).\n    *   Stream the live Binance order book (bids and asks) for subscribed trading pairs to all connected clients. This involves broadcasting snapshots or deltas of the Binance order book. This data is crucial for real-time order book visualization.\n\n2.  **User-Specific Trade Notifications (User vs. Binance):**\n    *   Capture user trade execution events when their orders are filled against the Binance order book (e.g., via `MatchingEngine.js`).\n    *   Broadcast trade details (pair, price, quantity, direction, timestamp, fee) specifically to the user involved in the trade.\n\n3.  **User Balance Updates:**\n    *   Broadcast updates to a user's asset balances resulting from their trades against Binance, deposits, withdrawals, or fee deductions. These updates are sent only to the specific user.\n\n4.  **Visual Consumption Feedback for User Trades:**\n    *   When a user's market order executes against the Binance order book, identify the specific liquidity (price levels and quantities) consumed.\n    *   Broadcast this consumption information to the user's client to enable visual feedback on their displayed Binance order book (e.g., highlighting affected price levels).\n\n5.  **WebSocket Messaging Formats:**\n    *   Define clear WebSocket message formats. Suggested formats:\n        *   User Trade Notification (vs. Binance): `{ type: 'TRADE_EXECUTED', pair: 'SIM_BTC/SIM_USD', data: { tradeId, orderId, price, quantity, side, timestamp, fee, feeCurrency } }`\n        *   Balance Update: `{ type: 'BALANCE_UPDATE', data: { asset: 'SIM_USD', total: '1000.00', available: '950.00' } }` (per asset)\n        *   Binance Order Book: `{ type: 'BINANCE_ORDER_BOOK_UPDATE', pair: 'SIM_BTC/SIM_USD', data: { bids: [[price, qty], ...], asks: [[price, qty], ...], lastUpdateId: 12345678 } }`\n        *   Visual Consumption Feedback: `{ type: 'TRADE_IMPACT_ON_BOOK', pair: 'SIM_BTC/SIM_USD', data: { tradeId, consumedBids: [[price, qtyConsumed], ...], consumedAsks: [[price, qtyConsumed], ...] } }`\n\n6.  **Integration Points:**\n    *   `MatchingEngine.js`: Source for user trade execution events against Binance.\n    *   `UserOrderService.js` / `AccountService.js`: For events leading to user balance changes.\n    *   `BinanceStreamService.js` (from Task 18): Source for live Binance order book data.\n    *   WebSocket infrastructure (Task 14): For broadcasting messages.",
      "testStrategy": "1.  Verify that individual users receive WebSocket messages for trade notifications when their orders are executed against the Binance order book, containing accurate trade details.\n2.  Confirm that individual users receive balance updates correctly and promptly after their trades against Binance or other relevant account activities.\n3.  Ensure that live Binance order book data (snapshots or diffs) is streamed accurately and efficiently to all subscribed clients for relevant pairs.\n4.  Test the visual consumption feedback mechanism:\n    *   Verify that messages indicating consumed liquidity from the Binance book are sent to the user after their market orders execute against Binance.\n    *   Ensure the data provided is sufficient for the frontend to correctly visualize the impact on the displayed order book.\n5.  Validate the structure, content, and correctness of all defined WebSocket message types.\n6.  Test system performance and reliability with multiple connected clients, various trading pairs, and high-frequency updates from Binance.\n7.  Ensure proper subscription management for different message types (e.g., user-specific vs. broadcast-to-all) and trading pairs.",
      "subtasks": [
        {
          "id": "19_1",
          "title": "Design WebSocket message formats for broadcasting Binance data and user activity",
          "status": "pending",
          "description": "Define clear and efficient JSON formats for all WebSocket messages: user-specific trade notifications for trades against Binance (e.g., `TRADE_EXECUTED`), user balance updates (e.g., `BALANCE_UPDATE`), live Binance order book data (e.g., `BINANCE_ORDER_BOOK_UPDATE`), and visual consumption feedback (e.g., `TRADE_IMPACT_ON_BOOK`). Specify the exact payload for each message type."
        },
        {
          "id": "19_2",
          "title": "Implement broadcasting of user trade notifications (vs. Binance) and balance updates",
          "status": "pending",
          "description": "Develop server-side logic (e.g., in a `NotificationService.js`) to capture user trade execution events against the Binance order book and associated balance change events. Broadcast these events as formatted WebSocket messages (using formats from `19_1`) to the specific user involved."
        },
        {
          "id": "19_3",
          "title": "Integrate user trade (vs. Binance) and account events for notifications",
          "status": "pending",
          "description": "Ensure that events from `MatchingEngine.js` (for user trade executions against Binance) and services managing user accounts/orders (e.g., `UserOrderService.js`, `AccountService.js`) correctly trigger the broadcasting of user-specific trade notifications and balance updates via the system developed in `19_2`."
        },
        {
          "id": "19_4",
          "title": "Implement broadcasting of live Binance order book data to all clients",
          "status": "pending",
          "description": "Integrate the Binance data feed from `BinanceStreamService.js` (Task 18) with the WebSocket broadcasting module. Implement logic to stream live Binance order book data (bids, asks, and potentially update identifiers) for subscribed trading pairs to all connected clients, using the format defined in `19_1`."
        },
        {
          "id": "19_5",
          "title": "Implement visual consumption feedback for user trades on Binance order book",
          "status": "pending",
          "description": "Develop the server-side mechanism to identify liquidity consumed from the Binance order book by user market orders. Broadcast this information (e.g., via a `TRADE_IMPACT_ON_BOOK` message, as defined in `19_1`) to the user's client, enabling visual feedback on the displayed order book."
        },
        {
          "id": "19_6",
          "title": "Develop tests for real-time broadcasting of Binance data and user activity",
          "status": "pending",
          "description": "Write comprehensive unit and integration tests covering: broadcasting of user-specific trade notifications (for trades against Binance), user balance updates, live Binance order book data to all clients, and visual consumption feedback. Verify WebSocket message formats (from `19_1`), data integrity, subscription logic (e.g., user-specific vs. broadcast-to-all), and timely delivery of messages."
        }
      ]
    },
    {
      "id": 20,
      "title": "FE: Real-time Order Book Visualization",
      "description": "Create a Svelte component to visualize the live Binance order book (bids and asks). This component will subscribe to Binance order book WebSocket updates via the backend for the selected cryptocurrency pair, efficiently re-render the display when new data arrives, and provide visual feedback when user trades consume Binance liquidity. The goal is a clean, real-time visualization of market depth from Binance.",
      "status": "pending",
      "dependencies": [
        8,
        15,
        19
      ],
      "priority": "high",
      "details": "Create `OrderBook.svelte` component. Props: `selectedPair`.\n1. On component mount or when `selectedPair` changes: send a WebSocket message to the backend to subscribe to Binance order book updates for that pair.\n2. Listen for messages from the backend (e.g., `BINANCE_ORDER_BOOK_UPDATE`) containing Binance order book data.\n3. When data arrives, update local Svelte stores or component state for Binance bids and asks.\n4. Render two lists (bids in green, asks in red), sorted by price, showing price, quantity, and cumulative quantity, representing Binance market depth.\n5. Implement visual feedback (e.g., highlighting, animations) on the order book display when a user's trade consumes liquidity from the Binance order book. This requires identifying which orders were affected by the user's trade.\n6. Ensure efficient DOM updates using Svelte's reactivity (`{#each ... key=...}`) for high-frequency Binance data.\n7. Focus on a clean and clear visualization of market depth from Binance. Remove any logic related to user-to-user order book display or matching.",
      "testStrategy": "1. Verify that the component correctly displays real-time Binance order book bids and asks for the selected pair.\n2. Confirm that the display updates efficiently in near real-time when new data arrives from the Binance WebSocket stream (via backend).\n3. Test that bids are displayed in green and asks in red, correctly sorted by price, and show price, quantity, and cumulative quantity.\n4. Validate the visual feedback mechanism: when a user's trade is executed against Binance liquidity, the corresponding levels in the order book should visually indicate consumption.\n5. Ensure the visualization of Binance market depth is clean, easy to understand, and accurately reflects data from Binance.\n6. Performance should be acceptable under high-frequency updates from Binance.\n7. Verify that subscription and unsubscription to Binance order book data via the backend works correctly when `selectedPair` changes or component unmounts.",
      "subtasks": [
        {
          "id": "20.1",
          "title": "Setup `OrderBook.svelte` component with `selectedPair` prop.",
          "status": "pending"
        },
        {
          "id": "20.2",
          "title": "Implement WebSocket communication with the backend to subscribe/unsubscribe to live Binance order book data for the `selectedPair`.",
          "status": "pending"
        },
        {
          "id": "20.3",
          "title": "Develop logic to process and store incoming Binance order book updates (bids and asks) efficiently.",
          "status": "pending"
        },
        {
          "id": "20.4",
          "title": "Render the Binance bids and asks lists, displaying price, quantity, and cumulative quantity. Style bids in green and asks in red, sorted by price.",
          "status": "pending"
        },
        {
          "id": "20.5",
          "title": "Design and implement visual feedback on the order book display when a user's trade consumes Binance liquidity (e.g., highlighting affected orders).",
          "status": "pending"
        },
        {
          "id": "20.6",
          "title": "Optimize component rendering for high-frequency Binance data updates using Svelte's reactivity and best practices.",
          "status": "pending"
        },
        {
          "id": "20.7",
          "title": "Ensure the overall visualization of Binance market depth is clean, intuitive, and updates in near real-time.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 21,
      "title": "BE: Real-time User Notifications Service",
      "description": "Implement a backend service to send targeted real-time notifications (e.g., order filled, order partially filled, insufficient funds, balance updates) to specific users via WebSockets.",
      "details": "Maintain a mapping of connected WebSocket clients to user IDs (e.g., store `userId` on `ws` object after authentication via socket, or have clients send their JWT for initial socket auth). When an event occurs (e.g., order fill from `TradeExecution`): identify the relevant user(s). Send a targeted WebSocket message. Example: `{ type: 'USER_NOTIFICATION', message: 'Your buy order for 1 SIM_BTC at 10000 SIM_USD was filled.', details: {...} }` or `{ type: 'BALANCE_UPDATE', currency: 'SIM_USD', newBalance: 5000 }`.",
      "testStrategy": "Specific users receive notifications relevant to their actions (e.g., trade confirmations, balance changes). Other users do not receive these notifications. Messages are correctly formatted.",
      "priority": "medium",
      "dependencies": [
        14,
        18
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 22,
      "title": "FE: Display Real-time User Notifications",
      "description": "Develop frontend logic to listen for user-specific WebSocket notifications and display them to the user (e.g., as toast messages or in a notification feed). Dynamically update displayed balances if a balance update notification is received.",
      "details": "In Svelte client, listen for `USER_NOTIFICATION` and `BALANCE_UPDATE` messages. For `USER_NOTIFICATION`, display the message using a toast component (e.g., `svelte-toast`) or add to a list. For `BALANCE_UPDATE`, update the Svelte store holding user balances, which should reactively update the UI (e.g., `AccountDashboard.svelte`).",
      "testStrategy": "User sees notifications for their own trade events. Balances displayed on the dashboard update automatically when a balance notification is received via WebSocket.",
      "priority": "medium",
      "dependencies": [
        10,
        15,
        21
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 23,
      "title": "BE/FE: Stripe Integration for Simulated Fiat Deposits",
      "description": "Integrate Stripe for simulated fiat deposits. Frontend: use Stripe Elements to collect test card details and get a payment token. Backend: API endpoint to receive token, use Stripe Node.js SDK to create a test charge. On success, update user's fiat balance in `Accounts` table and create a `Transaction` record.",
      "details": "FE: Add 'Deposit Fiat' section. Use `@stripe/stripe-js` and `@stripe/react-stripe-js` (or Svelte equivalent for Stripe Elements). Collect amount, use Stripe Elements for card form. On submit, call `stripe.createPaymentMethod()` or `stripe.confirmCardPayment()`. Send paymentMethodId/token and amount to backend. BE: `/payments/stripe-deposit` POST endpoint. Use `stripe` Node.js library (`npm install stripe`). `stripe.paymentIntents.create({ amount, currency: 'usd', payment_method, confirm: true })` with test keys. On success: update user's 'SIM_USD' balance in `Accounts`. Create a `Transactions` record (user_id, type='deposit_fiat', currency_code='SIM_USD', amount, status='completed', external_transaction_id=stripe_charge_id). The `Transactions` table schema needs to be defined (similar to PRD: transaction_id, user_id, type, currency_code_or_crypto_id, amount, status, external_transaction_id, timestamp).",
      "testStrategy": "User can go through Stripe test payment flow. Successful test payment updates user's fiat balance on backend and in UI. A transaction record is created. Stripe dashboard shows test transaction.",
      "priority": "medium",
      "dependencies": [
        4,
        9,
        11
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 24,
      "title": "BE/FE: Crypto Wallet Integration - Simulated Deposits",
      "description": "Implement basic crypto wallet integration for simulated deposits. Frontend: display a unique (or shared for simulation) testnet deposit address for a selected crypto. Backend: mechanism to (manually or via script) monitor this address on a testnet (e.g., Sepolia for ETH, Solana testnet for SOL). On detecting a 'deposit', credit user's `CryptoHolding` balance and create a `Transaction` record.",
      "details": "FE: 'Deposit Crypto' section. User selects crypto (e.g., 'SIM_ETH_Sepolia'). Display a fixed testnet address controlled by the application. BE: For simulation, this might be a manual process initially: admin checks testnet explorer (Etherscan Sepolia) for incoming transactions to the exchange's address. If a deposit is confirmed, admin manually triggers an API endpoint or DB update to credit user's `CryptoHoldings` for the specific crypto and create a `Transactions` record (type='deposit_crypto'). More advanced: script using `ethers.js` or `@solana/web3.js` to periodically query balance/transactions for the exchange's address.",
      "testStrategy": "User is shown a deposit address. After simulating a testnet transfer to this address, their simulated crypto balance is updated on the platform (manually or via script). A transaction record is created.",
      "priority": "low",
      "dependencies": [
        4,
        9,
        11,
        23
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 25,
      "title": "BE/FE: Crypto Wallet Integration - Simulated Withdrawals",
      "description": "Implement basic crypto wallet integration for simulated withdrawals. Frontend: form for withdrawal address and amount. Backend: API to receive request, check balance, simulate transfer (log it, no actual testnet transaction unless time permits), debit user's `CryptoHolding` balance, and create a `Transaction` record.",
      "details": "FE: 'Withdraw Crypto' section. User selects crypto, enters amount and their external testnet wallet address. Submit to backend. BE: `/wallet/initiate-withdrawal` POST endpoint. Validate user has sufficient balance in `CryptoHoldings`. If yes: debit balance. Create `Transactions` record (type='withdrawal_crypto', status='pending' or 'completed' for simulation). For actual testnet transaction (advanced): use `ethers.js` or `@solana/web3.js` with exchange's private key to send funds. For simulation, just log the intent.",
      "testStrategy": "User can request a withdrawal. If sufficient balance, simulated balance is debited. A transaction record is created. If actual testnet tx implemented, verify on explorer.",
      "priority": "low",
      "dependencies": [
        4,
        9,
        11,
        23,
        24
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 26,
      "title": "BE/FE: Trade History Feature",
      "description": "Develop a feature for users to view their trade history. Backend: API endpoint to fetch all trades for the authenticated user from the `Trades` table. Frontend: Display this history in a clear, tabular format.",
      "details": "BE: `/trades/history` GET endpoint, protected by auth. Query `Trades` table for records where `buyer_user_id` or `seller_user_id` matches `req.user.id`. Return list of trades (pair, type (buy/sell from user's perspective), quantity, price, timestamp). FE: `TradeHistory.svelte` component. Fetch data from `/trades/history`. Display in a table.",
      "testStrategy": "User can view their past trades. Data should be accurate and match records in the `Trades` table. Display should clearly indicate if user was buyer or seller for each trade.",
      "priority": "medium",
      "dependencies": [
        4,
        18
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 27,
      "title": "BE/FE: (Optional) Admin Panel Basics",
      "description": "If time permits, implement basic admin functionalities. This could include a simple UI and corresponding backend APIs for an 'admin' role to view all users, manage list of tradable cryptocurrencies (add/edit/disable), or view system-wide trade statistics.",
      "details": "BE: Define 'admin' role in `Users` table. Create admin-only routes protected by authorization middleware (e.g., `/admin/users`, `/admin/cryptocurrencies`). Implement logic for admin actions. FE: Create separate admin section/components, visible only to admin users. Display relevant data and provide forms for admin actions.",
      "testStrategy": "Admin user can log in and access admin panel. Non-admin users cannot. Admin actions (e.g., disabling a cryptocurrency) reflect correctly in the system.",
      "priority": "low",
      "dependencies": [
        4,
        7
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 28,
      "title": "FE: UI/UX Styling & Refinement",
      "description": "Apply consistent styling across the Svelte application. Focus on clarity, simplicity, and usability, especially for the target 'Curious Learner' persona. Ensure basic responsiveness and address the 'attempt at styling' soft requirement. Consider a lightweight CSS framework or custom CSS.",
      "details": "Use global CSS styles or component-scoped styles in Svelte. Choose a color scheme, typography. Ensure consistent layout for forms, tables, navigation. Make interactive elements clear. Test on common desktop screen sizes. Consider using Pico.CSS, OpenProps, or custom CSS for a clean look. Focus on readability of order book and trading forms.",
      "testStrategy": "Application has a consistent and presentable visual appearance. Key user flows are intuitive. No major layout issues on desktop. Meets 'attempt at styling' requirement.",
      "priority": "medium",
      "dependencies": [
        5,
        6,
        8,
        10,
        13,
        20,
        22,
        23,
        24,
        25,
        26
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 29,
      "title": "ALL: GDPR Compliance Implementation",
      "description": "Implement GDPR compliance measures. This includes data minimization in logging and data storage, providing a clear privacy statement/policy page, and outlining (or implementing stubs for) how user data requests (export, deletion) would be handled. This is a 'production ready' hard requirement.",
      "details": "Review all data stored and logged; ensure only necessary data is kept. Create a static `PrivacyPolicy.svelte` page outlining data usage, storage, user rights. For data export/deletion: plan the process. For MVP, this might be a statement that users can contact support, and backend stubs for admin to manually process requests. Ensure user consent for cookies/tracking if any are used beyond essential session management.",
      "testStrategy": "Privacy policy page is accessible. Data handling practices reviewed for minimization. Plan for data subject requests is documented. No unnecessary personal data logged.",
      "priority": "high",
      "dependencies": [
        28
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 30,
      "title": "ALL: Final Testing, Code Cleanup & Documentation",
      "description": "Conduct comprehensive end-to-end testing of all user flows and features. Remove all `console.log` statements, unused code, and unfinished snippets. Ensure code style is consistent. Write or update documentation for key architectural decisions and setup. Prepare for showcasing the application.",
      "details": "Manually test all user flows: registration, login, viewing markets, placing orders, trade execution, balance updates, notifications, deposits/withdrawals, trade history. Fix any bugs. Search codebase for `console.log` and remove. Delete commented-out code blocks and unused files/functions. Run linters/formatters. Document database schema, API endpoints, and any complex logic (e.g., matching engine). Prepare demo script for exam.",
      "testStrategy": "All features work as expected. Codebase is clean and meets 'production ready' requirements. Documentation is sufficient for understanding the project. Application is ready for demonstration.",
      "priority": "high",
      "dependencies": [
        29
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 31,
      "title": "BE: OpenAPI Specification Compliance",
      "description": "Refactor all API endpoints to comply with OpenAPI specifications",
      "details": "Create OpenAPI specification document and ensure all endpoints follow standards for request/response formats, status codes, error responses, and data schemas. Add validation middleware and documentation generation.",
      "testStrategy": "",
      "status": "done",
      "dependencies": [
        1,
        2,
        3,
        4,
        "33"
      ],
      "priority": "high",
      "subtasks": []
    },
    {
      "id": 32,
      "title": "BE: Error Handling Architecture Refactor",
      "description": "Remove all error handling from services and repositories, centralizing it in routers",
      "details": "Refactor the backend architecture to move all try-catch blocks and error handling logic from service and repository layers to their respective routers. Services and repositories should throw errors and let routers handle HTTP responses and status codes.",
      "testStrategy": "",
      "status": "done",
      "dependencies": [
        1,
        2,
        3,
        4
      ],
      "priority": "high",
      "subtasks": [
        {
          "id": 1,
          "title": "Audit Current Error Handling in Services and Repositories",
          "description": "Review all existing service and repository files to identify current error handling patterns and try-catch blocks that need to be moved to routers",
          "details": "",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 32
        },
        {
          "id": 2,
          "title": "Refactor User Services to Remove Error Handling",
          "description": "Remove try-catch blocks from user services and let them throw errors instead",
          "details": "",
          "status": "done",
          "dependencies": [
            1
          ],
          "parentTaskId": 32
        },
        {
          "id": 3,
          "title": "Refactor Other Services (Crypto, Account, Order) to Remove Error Handling",
          "description": "Remove try-catch blocks from cryptocurrency, account, and order services",
          "details": "",
          "status": "done",
          "dependencies": [
            1
          ],
          "parentTaskId": 32
        },
        {
          "id": 4,
          "title": "Update All Routers with Centralized Error Handling",
          "description": "Add proper try-catch blocks and error handling to all router files to handle errors thrown by services",
          "details": "",
          "status": "done",
          "dependencies": [
            2,
            3
          ],
          "parentTaskId": 32
        },
        {
          "id": 5,
          "title": "Test and Verify Error Handling Refactor",
          "description": "Test all endpoints to ensure error handling works correctly and consistently across all routers",
          "details": "<info added on 2025-06-01T14:09:48.577Z>\nSuccessfully identified and fixed authentication middleware OpenAPI compliance issue. Authentication error handling now works correctly:\n\nFixed authentication middleware to use sendUnauthorized helper.\nVerified accounts endpoint returns proper 401 with error object.\nVerified orders endpoint returns proper 401 with error object.\nRemoved hardcoded authentication bypass (completed Task 35).\n\nThe error handling refactor is working correctly. All routers have comprehensive try-catch blocks and proper error response formatting.\n</info added on 2025-06-01T14:09:48.577Z>\n<info added on 2025-06-01T14:11:53.726Z>\nCompleted comprehensive error handling verification across all routers:\n\nAuthentication Errors: 401 responses with proper error format\nValidation Errors: 400/422 responses for OpenAPI and custom validation\nBusiness Logic Errors: 409 for conflicts, 422 for custom business rules\nResource Not Found: 404 responses with proper error messages\nInput Validation: 400 responses for malformed parameters\nAuthenticated Endpoints: Proper success responses with valid sessions\nAuthenticated Error Handling: 404 errors work correctly in authenticated context\n\nAll routers consistently use proper error response format:\n{\n  \"error\": \"ErrorType\",\n  \"message\": \"Descriptive error message\"\n}\n\nStatus codes are appropriate:\n- 400: Bad Request (OpenAPI validation)\n- 401: Unauthorized (authentication required)\n- 404: Not Found (resource doesn't exist)\n- 409: Conflict (duplicate resources)\n- 422: Unprocessable Entity (business rule violations)\n\nError handling refactor is complete and working perfectly.\n</info added on 2025-06-01T14:11:53.726Z>",
          "status": "done",
          "dependencies": [
            4
          ],
          "parentTaskId": 32
        }
      ]
    },
    {
      "id": 33,
      "title": "BE: Validation Schemas Implementation",
      "description": "Create comprehensive validation schemas for all existing features using a validation library",
      "details": "Implement validation schemas for all existing backend features including users, auth, cryptocurrencies, accounts, and orders. Choose and integrate a validation library (e.g., Joi, Yup, or Zod) and create reusable validation schemas for request bodies, query parameters, and response data. This includes validation for registration, login, cryptocurrency data, account balances, and order placement.",
      "testStrategy": "",
      "status": "done",
      "dependencies": [
        1,
        2,
        3,
        4
      ],
      "priority": "high",
      "subtasks": []
    },
    {
      "id": 34,
      "title": "BE: API Key Authentication System",
      "description": "Implement API key generation and authentication system for API access",
      "details": "Create a system for generating, managing, and authenticating API keys for external access to the trading platform APIs. This includes API key generation endpoints, storage in database, middleware for API key validation, and rate limiting per API key. This is a non-urgent enhancement for future API access management.",
      "testStrategy": "",
      "status": "pending",
      "dependencies": [
        4,
        31,
        32,
        33
      ],
      "priority": "low",
      "subtasks": []
    },
    {
      "id": 35,
      "title": "BE: Fix Authentication Middleware Security Bypass",
      "description": "Remove hardcoded authentication bypass from backend/shared/middleware/authorisation.js. The middleware currently hardcodes userId=1 and role='admin' for all requests instead of validating sessions. This creates a critical security vulnerability.",
      "details": "1. Remove the hardcoded authentication bypass (lines 9-14 in authorisation.js)\n2. Uncomment and restore the proper session validation logic (lines 2-8)\n3. Ensure proper 401 responses for unauthenticated requests\n4. Verify req.user is correctly populated from session data\n5. Test all protected endpoints to ensure authentication works correctly\n\nThis is critical for application security before any production deployment.",
      "testStrategy": "1. Test that protected routes return 401 when no session cookie is sent\n2. Test that protected routes return 401 when session exists but userId is missing\n3. Test that protected routes allow access when valid session exists\n4. Verify req.user is correctly populated with session data\n5. Test logout functionality properly destroys sessions",
      "status": "done",
      "dependencies": [
        32,
        33
      ],
      "priority": "high",
      "subtasks": []
    },
    {
      "id": 36,
      "title": "BE: Restore OpenAPI Cookie Authentication Validation",
      "description": "Ensure the OpenAPI specification properly validates cookie authentication and that the cookieAuth security scheme is correctly configured for all protected endpoints.",
      "details": "1. Verify the cookieAuth security scheme is properly defined in openapi.yml components/securitySchemes\n2. Ensure all protected endpoints have the 'security: - cookieAuth: []' declaration\n3. Confirm the OpenAPI validation middleware correctly validates cookies before requests reach application middleware\n4. Test that OpenAPI validation rejects requests without proper cookies\n5. Ensure API documentation accurately reflects authentication requirements\n\nThis provides the first line of defense and ensures API documentation accuracy.",
      "testStrategy": "1. Test that OpenAPI validation rejects requests without connect.sid cookie\n2. Test that OpenAPI validation rejects requests with invalid session IDs\n3. Verify protected endpoints in API docs show authentication requirement\n4. Test that valid authenticated requests pass OpenAPI validation\n5. Confirm error responses match OpenAPI specification",
      "status": "deferred",
      "dependencies": [
        31,
        35
      ],
      "priority": "high",
      "subtasks": []
    },
    {
      "id": 37,
      "title": "Test AI Functionality with Google API Key",
      "description": "Perform comprehensive testing to verify that the Task Master AI features, integrated with the newly added Google API key, are operating correctly and delivering accurate results.",
      "details": "This task involves end-to-end testing of all AI-powered functionalities within the Task Master application.\nKey objectives include:\n1.  Confirmation that the Google API key is correctly configured and utilized by the AI modules.\n2.  Identification and systematic testing of each specific AI feature (e.g., AI-assisted task description generation, dependency suggestion, content summarization, etc.).\n3.  Validation of AI feature inputs, processing logic (at a high level), and output accuracy and relevance.\n4.  Ensuring backend services/APIs supporting these AI features are stable and responsive.\n5.  Verifying robust error handling for scenarios such as Google API errors (e.g., quota limits, invalid key, network connectivity issues) or invalid inputs to AI features.",
      "testStrategy": "1. **Environment & Configuration Verification**:\n    *   Confirm the Google API key is securely configured and accessible in the testing environment.\n    *   Ensure all AI-related modules/services are deployed and running.\n2.  **AI Feature Inventory & Test Case Design**:\n    *   Compile an exhaustive list of all implemented Task Master AI features.\n    *   For each feature, design specific test cases covering:\n        *   **Positive Scenarios**: Valid inputs expected to yield successful AI processing and relevant outputs.\n        *   **Edge Cases**: Inputs that test the boundaries of expected behavior.\n        *   **Negative Scenarios (Input Validation)**: Invalid or malformed inputs to ensure graceful error handling by the system before AI invocation (if applicable).\n3.  **Functional Testing (Per AI Feature)**:\n    *   Execute positive test cases: Provide valid inputs and meticulously verify the AI-generated output for accuracy, relevance, and correct formatting.\n    *   Execute edge case test cases: Observe system behavior and AI output.\n    *   Execute negative input test cases: Confirm user-friendly error messages and system stability.\n4.  **Google API Interaction & Error Handling Tests**:\n    *   Simulate Google API unavailability or errors (if feasible in a controlled test environment, e.g., by temporarily revoking/misconfiguring the key or using mock services that simulate error responses).\n    *   Verify that the Task Master application handles these external errors gracefully (e.g., informative messages to the user, proper logging, no crashes).\n    *   Test with a valid key that might hit a (test) quota limit if possible, to see how that's handled.\n5.  **Output Validation**:\n    *   For features generating text or suggestions, assess the quality, coherence, and usefulness of the AI output against predefined criteria or expert judgment.\n    *   For features making predictions or classifications, compare results against known outcomes if possible.\n6.  **Logging & Monitoring Review**:\n    *   Inspect application logs during testing for any errors, warnings, or unexpected behavior related to AI feature execution or Google API calls.\n    *   Verify that successful operations and significant errors are logged appropriately for diagnostics.\n7.  **Basic Performance Check**:\n    *   For interactive AI features, assess if the response time is acceptable from a user experience perspective. This is an observational check, not a formal load test.",
      "status": "pending",
      "dependencies": [
        35,
        36
      ],
      "priority": "low",
      "subtasks": []
    },
    {
      "id": 38,
      "title": "Simple MCP AI Functionality Verification",
      "description": "Perform a targeted, simple test to confirm a core capability of the MCP AI (Task Master AI) is functioning as expected, post-integration with the Google API key and initial comprehensive testing.",
      "details": "1. Prerequisite: MCP AI (Task Master AI) has been integrated with the Google API key and has undergone comprehensive testing (as per Task 37).\n2. Identify a single, straightforward AI function to test. Example: Given a short user story, the AI should generate 3 relevant tags.\n3. Input: A specific, concise user story (e.g., \"As a user, I want to reset my password so I can regain access to my account.\").\n4. Expected Output: A list of 3 relevant tags (e.g., [\"password reset\", \"account recovery\", \"security\"]). The expected tags should be predefined for the chosen test case.\n5. Execution:\n    a. Access the MCP AI interface or API endpoint.\n    b. Provide the defined input user story.\n    c. Capture the AI's generated tags.",
      "testStrategy": "1. Verify the MCP AI endpoint is accessible and responsive.\n2. Submit the predefined user story to the AI.\n3. Collect the generated tags from the AI's response.\n4. Compare the generated tags against the predefined expected tags. The test passes if the generated output sufficiently matches the expected output (e.g., at least 2 out of 3 tags match or are clear semantic equivalents, or as defined by the specific test case criteria).\n5. Document the input, expected output, actual output, and pass/fail result. Note any discrepancies or unexpected behavior for further review.",
      "status": "done",
      "dependencies": [
        37
      ],
      "priority": "low",
      "subtasks": []
    },
    {
      "id": 39,
      "title": "BE: Implement Google OAuth 2.0 Login Integration",
      "description": "Integrate Google OAuth 2.0 to allow users to sign in or register using their Google accounts. This involves backend setup for the OAuth flow, handling Google's callback, and managing user account creation/linking and session state.",
      "details": "### 1. Google Cloud Project Setup:\n   - Navigate to the Google Cloud Console.\n   - Create a new project or select an existing one.\n   - Enable the \"Google People API\" under \"APIs & Services -> Enabled APIs & Services\".\n   - Configure the OAuth consent screen under \"APIs & Services -> OAuth consent screen\":\n     - Specify User Type (e.g., External).\n     - Provide App name, User support email, App logo (optional).\n     - Add Scopes: `openid`, `https://www.googleapis.com/auth/userinfo.email`, `https://www.googleapis.com/auth/userinfo.profile`.\n     - Fill in developer contact information.\n   - Create OAuth 2.0 Client ID under \"APIs & Services -> Credentials\":\n     - Select Application type: \"Web application\".\n     - Name it (e.g., \"Exchange App Web Client\").\n     - Add Authorized JavaScript origins (e.g., frontend URL like `http://localhost:3001`).\n     - Add Authorized redirect URIs for the backend (e.g., `http://localhost:3000/api/auth/google/callback`).\n     - Securely store the generated Client ID and Client Secret (e.g., in environment variables).\n\n### 2. Backend Implementation (using Passport.js):\n   - Install necessary packages: `npm install passport passport-google-oauth20 express-session`.\n   - Ensure `express-session` middleware is configured and initialized before Passport middleware. This might be partially covered by Task 4 but ensure it's compatible with Passport's session needs.\n   - Initialize Passport middleware: `app.use(passport.initialize()); app.use(passport.session());`.\n   - Configure `passport-google-oauth20` strategy:\n     ```javascript\n     passport.use(new GoogleStrategy({\n       clientID: process.env.GOOGLE_CLIENT_ID,\n       clientSecret: process.env.GOOGLE_CLIENT_SECRET,\n       callbackURL: '/api/auth/google/callback',\n       scope: ['profile', 'email']\n     },\n     async (accessToken, refreshToken, profile, done) => {\n       try {\n         const googleId = profile.id;\n         const email = profile.emails && profile.emails[0] ? profile.emails[0].value : null;\n         const firstName = profile.name ? profile.name.givenName : '';\n         const lastName = profile.name ? profile.name.familyName : '';\n\n         if (!email) {\n           return done(new Error('Email not provided by Google.'), null);\n         }\n\n         let user = await User.findOne({ where: { googleId: googleId } });\n         if (user) {\n           return done(null, user);\n         }\n\n         user = await User.findOne({ where: { email: email } });\n         if (user) {\n           // Link Google ID to existing email account\n           user.googleId = googleId;\n           // Optionally update name fields if they are empty or prefer Google's\n           user.firstName = user.firstName || firstName;\n           user.lastName = user.lastName || lastName;\n           user.isEmailVerified = true; // Google verifies email\n           await user.save();\n           return done(null, user);\n         }\n\n         // Create new user\n         const newUser = await User.create({\n           googleId: googleId,\n           email: email,\n           firstName: firstName,\n           lastName: lastName,\n           isEmailVerified: true, // Email from Google is considered verified\n           // Password field can be null or a placeholder if schema requires it for OAuth users\n           // Ensure User model (from Task 3) accommodates this\n         });\n         return done(null, newUser);\n       } catch (err) {\n         return done(err, null);\n       }\n     }));\n     ```\n   - Implement Passport `serializeUser` and `deserializeUser` for session management:\n     ```javascript\n     passport.serializeUser((user, done) => {\n       done(null, user.id); // Assuming user object has an 'id' property (PK)\n     });\n\n     passport.deserializeUser(async (id, done) => {\n       try {\n         const user = await User.findByPk(id);\n         done(null, user);\n       } catch (err) {\n         done(err);\n       }\n     });\n     ```\n   - Update User model/schema (from Task 2/3) to include `googleId` (String, unique, nullable), `firstName`, `lastName`, and `isEmailVerified` (Boolean) fields if not already present.\n\n### 3. API Routes:\n   - **`GET /api/auth/google`**: Initiates the Google OAuth flow.\n     ```javascript\n     router.get('/auth/google', passport.authenticate('google'));\n     ```\n   - **`GET /api/auth/google/callback`**: Handles the callback from Google.\n     ```javascript\n     router.get('/auth/google/callback',\n       passport.authenticate('google', {\n         successRedirect: process.env.GOOGLE_OAUTH_SUCCESS_REDIRECT_URL || '/dashboard',\n         failureRedirect: process.env.GOOGLE_OAUTH_FAILURE_REDIRECT_URL || '/login?error=google_auth_failed',\n         failureMessage: true // Store failure message in req.session.messages\n       })\n     );\n     ```\n   - Ensure these routes adhere to OpenAPI specifications (Task 31) and centralized error handling (Task 32).\n\n### 4. Session Management:\n   - Successful authentication via Passport will establish a session using `express-session` and populate `req.user`.\n   - This session should be compatible with the authentication middleware from Task 4.",
      "testStrategy": "### 1. Unit Tests (e.g., Jest, Mocha):\n   - Test the Passport strategy's verify callback logic extensively:\n     - Mock `User.findOne`, `User.create`, `user.save`.\n     - Scenario: User found by `googleId`.\n     - Scenario: User found by `email` (account linking), verify `googleId` and `isEmailVerified` are updated.\n     - Scenario: New user creation, verify all fields are set correctly.\n     - Scenario: Google profile does not provide an email.\n     - Scenario: Database errors during find or save operations.\n   - Test `serializeUser` and `deserializeUser` with mock user objects and IDs.\n\n### 2. Integration Tests (e.g., Supertest):\n   - Test `GET /api/auth/google` endpoint:\n     - Verify it returns a 302 redirect.\n     - Verify the `Location` header in the response points to Google's OAuth URL with correct parameters (client_id, redirect_uri, scope, response_type).\n   - Test `GET /api/auth/google/callback` (requires mocking Google's response or a more complex setup):\n     - Simulate a successful callback from Google: Mock `passport.authenticate` or the strategy execution to return a mock user.\n       - Verify session cookie is set.\n       - Verify redirection to `successRedirect` URL.\n     - Simulate a failed callback from Google:\n       - Verify redirection to `failureRedirect` URL.\n       - Verify appropriate error message is available (e.g., in session or query param).\n\n### 3. Manual End-to-End Testing:\n   - **Prerequisites**: Frontend with a \"Sign in with Google\" button pointing to `/api/auth/google`.\n   - **Scenario 1: New User Registration**\n     - Use a Google account not previously registered in the application.\n     - Click \"Sign in with Google\", authenticate with Google, grant permissions.\n     - Verify successful redirection to the application's dashboard or specified success URL.\n     - Check database: A new user record should exist with `googleId`, email, name from Google, and `isEmailVerified` set to true.\n     - Verify session is active and user can access protected routes.\n   - **Scenario 2: Existing Google User Login**\n     - Log out. Use the same Google account from Scenario 1.\n     - Click \"Sign in with Google\".\n     - Verify successful login and redirection without creating a new user account.\n   - **Scenario 3: Linking Google to Existing Email Account**\n     - Create an account using traditional email/password (e.g., `test.user@example.com`).\n     - Log out. Click \"Sign in with Google\" using a Google account associated with `test.user@example.com`.\n     - Verify successful login. Check database: The existing user record for `test.user@example.com` should now have its `googleId` field populated and `isEmailVerified` set to true.\n   - **Scenario 4: Google Authentication Failure**\n     - On Google's consent screen, deny permission or simulate an error from Google's side.\n     - Verify redirection to the specified `failureRedirect` URL with an appropriate error indicator.\n   - **Scenario 5: Session Persistence**\n     - After logging in with Google, close and reopen the browser (if session is persistent) or navigate within the app.\n     - Verify the user remains logged in and the session is correctly managed by the middleware from Task 4.\n\n### 4. Security Checks:\n   - Verify Client ID and Client Secret are stored securely as environment variables and not exposed client-side.\n   - Ensure the `redirect_uri` configured in Google Cloud Console exactly matches the one used by the backend to prevent open redirector vulnerabilities.",
      "status": "pending",
      "dependencies": [
        3,
        4,
        31,
        32,
        33
      ],
      "priority": "medium",
      "subtasks": []
    },
    {
      "id": 40,
      "title": "Refactor Validation to Express.js Middleware with Valibot",
      "description": "Refactor existing validation logic from service layers to a centralized Express.js middleware pattern using Valibot schemas. This will improve separation of concerns and standardize error handling for request validation.",
      "details": "This task involves creating reusable Express.js middleware for request validation using the Valibot schemas developed in Task 33. Key steps include:\n1. Develop a generic validation middleware factory function. This function should accept a Valibot schema as an argument.\n2. The middleware should parse and validate `req.body`, `req.params`, and `req.query` against the provided schema.\n3. Upon successful validation, the middleware should call `next()` to pass control to the next handler. If Valibot parsing results in transformed/parsed data, it should be attached to `req` (e.g., `req.validatedData = parsedOutput`).\n4. If validation fails, the middleware must not call `next()`. Instead, it should immediately respond with a 400 Bad Request status and a JSON body detailing the validation errors, utilizing Valibot's error reporting capabilities for clear messages.\n5. Identify all routes currently performing validation within their service/controller logic.\n6. Integrate the new validation middleware into these Express routes, applying the appropriate Valibot schema for each.\n   Example: `router.post('/resource', validationMiddleware(resourceCreateSchema), resourceController.createResource);`\n7. Remove all data validation logic from the service layer methods. Services should now assume that incoming data has been pre-validated and is schema-compliant.\n8. Ensure that this refactoring centralizes validation error handling, providing consistent error responses across the API for input validation issues.",
      "testStrategy": "Verify the correct implementation through a combination of unit and integration tests:\n1. **Unit Tests for Validation Middleware**:\n   - Create test suites for the generic validation middleware factory.\n   - Test with various Valibot schemas (covering `body`, `params`, `query`).\n   - Mock `req`, `res`, `next` objects.\n   - Assert that `next()` is called when provided with valid data matching the schema.\n   - Assert that `res.status(400).json()` is called with a correctly structured error payload (derived from Valibot errors) when provided with invalid data, and `next()` is not called.\n   - Verify that parsed and validated data is correctly attached to the `req` object if applicable.\n2. **Integration Tests for Routes**:\n   - For each API endpoint refactored to use the new validation middleware:\n     - Send requests with valid payloads: Confirm the request passes validation, reaches the controller/service, and returns the expected successful response (e.g., 200 OK, 201 Created).\n     - Send requests with various invalid payloads (e.g., missing required fields, incorrect data types, values violating schema constraints): Confirm a 400 Bad Request response is returned with a JSON body detailing the specific validation errors. Ensure the underlying service logic is not executed.\n3. **Service Layer Tests Verification**:\n   - Review and update existing service layer tests to ensure they no longer test for input validation that is now handled by the middleware. Service tests should focus on business logic, assuming valid inputs.\n4. **Manual API Testing**:\n   - Use an API client (e.g., Postman) to manually test a selection of refactored endpoints with diverse valid and invalid inputs to confirm behavior and consistent error responses.",
      "status": "deferred",
      "dependencies": [
        33
      ],
      "priority": "medium",
      "subtasks": []
    },
    {
      "id": 41,
      "title": "BE: Refactor OrderService for Improved Maintainability and Testability",
      "description": "Refactor `save()` and `updateByUserAndOrderId()` methods in `OrderService.js` to eliminate code duplication, simplify complex logic using patterns like Strategy, and improve error handling and validation. This will enhance code maintainability, testability, and robustness of the core order processing functionality.",
      "details": "The refactoring of `OrderService.js` methods `save()` and `updateByUserAndOrderId()` will involve the following key activities:\n1.  **Balance Validation Logic Extraction:**\n    *   Identify and consolidate the balance validation logic currently duplicated in `save()` and `updateByUserAndOrderId()`.\n    *   Create a private method, e.g., `_validateAndReserveBalance(userId, orderDetails, existingOrder = null)`, responsible for verifying sufficient funds for both new orders and updates that might affect cost. This method should handle both fiat and crypto balances and consider existing reserved amounts if an order is being updated.\n    *   Refactor `save()` and `updateByUserAndOrderId()` to call this unified balance validation method.\n2.  **Dedicated Buy/Sell Order Processing Handlers:**\n    *   Create distinct private helper methods for buy and sell order logic, e.g., `_processNewBuyOrder(orderData, user)` and `_processNewSellOrder(orderData, user)` for the `save()` method.\n    *   Similarly, create `_processBuyOrderUpdate(orderData, existingOrder, user)` and `_processSellOrderUpdate(orderData, existingOrder, user)` for `updateByUserAndOrderId()` if update logic significantly differs based on order side.\n    *   These handlers will manage specifics like debiting/crediting the correct accounts, unique validation rules, and calculating costs/proceeds for buy vs. sell orders.\n3.  **Strategy Pattern for Order Type/Variant Processing:**\n    *   Define an `IOrderTypeStrategy` interface with methods like `validateOrderTypeSpecifics(orderData, existingOrder = null)`, `calculateCostAndFees(orderData)`, and `prepareOrderAttributes(orderData)`.\n    *   Implement concrete classes such as `LimitOrderStrategy` and `MarketOrderStrategy`.\n    *   `OrderService` methods (`save` and `updateByUserAndOrderId`) will use a context or factory to select and delegate to the appropriate strategy based on `orderData.order_type`. This will replace complex nested conditional structures for order type and variant checking.\n4.  **Consolidate Common Logic & Reduce Duplication:**\n    *   Review `save()` and `updateByUserAndOrderId()` for any remaining duplicated code beyond balance validation and type-specific processing (e.g., common database interaction patterns for creating/updating order records, status transitions, audit logging).\n    *   Extract these into well-named private helper methods to ensure DRY principles are followed throughout the service.\n5.  **Improved Error Handling and Validation Flow:**\n    *   Standardize error responses using specific, custom error classes (e.g., `InsufficientBalanceError`, `InvalidOrderParametersError`, `OrderUpdateNotAllowedError`).\n    *   Refine the validation sequence to be clear, efficient, and fail-fast. Ensure comprehensive validation of all input parameters and business rules.\n    *   Ensure all database operations within `save()` and `updateByUserAndOrderId()` are wrapped in transactions to maintain data integrity.\n6.  **Refactor `updateByUserAndOrderId()` Method:**\n    *   Specifically address the `updateByUserAndOrderId()` method to ensure it fully leverages the new extracted logic (balance validation, strategy pattern for any type-specific update rules, buy/sell handlers if applicable).\n    *   Clearly define which order attributes are updatable by users and enforce these limitations. Validate order status to prevent updates to non-updatable orders (e.g., filled, cancelled).\n    *   Ensure that updates correctly interact with the order's lifecycle and status transitions, and re-validate balances if necessary (e.g., if quantity is increased).",
      "testStrategy": "Verification of the refactored `OrderService.js` will be achieved through comprehensive unit testing:\n1.  **Unit Tests for Extracted Private Methods:**\n    *   For `_validateAndReserveBalance`: Test with sufficient/insufficient fiat/crypto balances for new orders and updates, various user scenarios, and correct handling of existing reservations.\n    *   For `_processNewBuyOrder`/`_processNewSellOrder` (and update counterparts): Test correct processing flow, data transformation, and interaction with mocked dependencies for buy/sell specific logic.\n2.  **Unit Tests for Strategy Pattern Components:**\n    *   For each `IOrderTypeStrategy` implementation (e.g., `LimitOrderStrategy`, `MarketOrderStrategy`):\n        *   Test `validateOrderTypeSpecifics()` with valid and invalid order data specific to that type (e.g., presence/absence of price for limit/market).\n        *   Test `calculateCostAndFees()` for accurate calculations under various conditions.\n        *   Test `prepareOrderAttributes()` for correct construction of order attributes specific to the type.\n3.  **Unit Tests for `save()` Method (Orchestration Logic):**\n    *   Mock all dependencies (database repository, strategy processors, private helper methods).\n    *   Verify that `save()` correctly orchestrates calls to these components for various scenarios: successful limit buy/sell, successful market buy/sell, failures due to balance validation, failures due to order type specific validation, and correct error propagation.\n4.  **Unit Tests for `updateByUserAndOrderId()` Method (Orchestration Logic):**\n    *   Mock all dependencies.\n    *   Verify correct orchestration for scenarios: successful updates (e.g., quantity/price changes if allowed), attempts to update non-existent orders, unauthorized updates (if service layer checks exist), updates to orders in non-updatable states, updates failing due to re-validation (e.g., balance check for increased quantity), and correct error propagation.\n5.  **Error Handling Tests:**\n    *   Ensure that custom error classes are thrown correctly by the service under appropriate failure conditions (e.g., `InsufficientBalanceError`, `InvalidOrderParametersError`).\n    *   Verify that database transaction rollbacks are correctly handled/simulated in tests upon service method failure.\n6.  **Test Coverage:**\n    *   Utilize a code coverage tool (e.g., Jest's built-in coverage) to ensure a high percentage (target >90%) of the refactored code in `OrderService.js` is covered by unit tests, especially critical paths and decision points.\n7.  **Regression Testing:**\n    *   Ensure all existing unit tests related to `OrderService` (if any) continue to pass after refactoring.\n    *   If available, run relevant integration tests that involve order creation and updates to catch any unintended side effects not covered by unit tests.",
      "status": "pending",
      "dependencies": [
        12,
        18
      ],
      "priority": "medium",
      "subtasks": []
    },
    {
      "id": 42,
      "title": "BE: Correct Market Order Execution to Use Actual Market Price",
      "description": "Fix a critical bug in market order processing where user-provided prices are incorrectly used. This task ensures all market orders execute at the prevailing market price at the time of order placement, and all balance and trade calculations accurately reflect this.",
      "details": "The core issue is that market orders are currently processed using a price that might be provided by the user, instead of the actual live market price. This can lead to incorrect valuation of trades and potential discrepancies in user balances.\n\nImplementation Steps:\n1.  **Identify Target Modules:** Locate the code sections responsible for handling market order ingestion, validation, and execution. This may include services like `OrderService`, `OrderMatchingEngine` (related to Task 17), or `TradeExecutionService` (related to Task 18).\n2.  **Ignore User-Provided Price for Market Orders:** Modify the logic to ensure that any 'price' field submitted with a market order is disregarded for execution purposes. The `price` field in the request for market orders is optional as per Task 12; this fix ensures it's not used even if present.\n3.  **Fetch Current Market Price:** Integrate with the designated price oracle (e.g., functionality developed in Task 16, using `binance-ws.js` or similar) to fetch the real-time market price (best ask for buys, best bid for sells) when a market order is being processed.\n4.  **Pre-Execution Balance Validation:** Crucially, all pre-execution balance checks must use the fetched *actual market price*.\n    *   For a **buy** order: `required_fiat = quantity * current_market_ask_price`. Check if user's fiat balance >= `required_fiat`.\n    *   For a **sell** order: Check if user's crypto balance >= `quantity`. The proceeds will be calculated using the `current_market_bid_price`.\n5.  **Execution at Market Price:** Ensure the order execution logic uses the fetched market price to determine the terms of the trade. The `executed_price` for the order and any resulting trades must be this market price.\n6.  **Update Balances and Record Trades:** All subsequent balance updates (debiting/crediting fiat and crypto) and the creation of `Trade` records must use the actual market price at which the order was executed. The `Trade` record should accurately reflect the quantity and the market-determined execution price.\n7.  **Atomicity and Error Handling:** Ensure that fetching the price, validating balances, executing the order, and updating records are performed atomically to maintain data consistency. Implement robust error handling for scenarios such as failure to fetch market price (in which case the order should likely be rejected or queued with caution) or insufficient balances based on the true market price.",
      "testStrategy": "Verify the fix through a combination of unit, integration, and scenario-based testing:\n\n1.  **Unit Tests:**\n    *   Test the specific function/method responsible for determining the execution price for market orders. Mock the price oracle.\n    *   Verify that if a user provides a price with a market order, it is ignored.\n    *   Verify that the correct market price (ask for buy, bid for sell) is fetched and used.\n    *   Test balance calculation logic with mocked market prices.\n\n2.  **Integration Tests (Order Placement to Execution):**\n    *   **Scenario 1: Market Buy Order - User price lower than market**\n        *   Setup: User fiat balance: 100 USD. Actual market price for ASSET_X: 10 USD/ASSET_X. User places market buy for 5 ASSET_X, erroneously providing price = 8 USD.\n        *   Expected: Order executes at 10 USD/ASSET_X. Cost = 50 USD. User fiat balance becomes 50 USD. User ASSET_X balance increases by 5. Trade record shows execution price of 10 USD.\n    *   **Scenario 2: Market Buy Order - Insufficient funds at actual market price**\n        *   Setup: User fiat balance: 40 USD. Actual market price for ASSET_X: 10 USD/ASSET_X. User places market buy for 5 ASSET_X (cost at market = 50 USD), may or may not provide a price.\n        *   Expected: Order is rejected due to insufficient funds when validated against the actual market price.\n    *   **Scenario 3: Market Sell Order - User price higher than market**\n        *   Setup: User ASSET_X balance: 10. Actual market price for ASSET_X: 10 USD/ASSET_X. User places market sell for 5 ASSET_X, erroneously providing price = 12 USD.\n        *   Expected: Order executes at 10 USD/ASSET_X. Proceeds = 50 USD. User ASSET_X balance becomes 5. User fiat balance increases by 50 USD. Trade record shows execution price of 10 USD.\n    *   **Scenario 4: Market Orders - No user-provided price**\n        *   Test both buy and sell market orders where no price is provided by the user.\n        *   Expected: Orders execute at the prevailing market price, and balances/trades are updated correctly.\n\n3.  **Database Verification:**\n    *   After test trades, inspect the `Orders` table to ensure `executed_price` (if applicable) and status are correct.\n    *   Inspect the `Trades` table to confirm `price`, `quantity`, and `total_value` are based on the actual market price.\n    *   Verify `Accounts` and `CryptoHoldings` tables reflect correct balance changes.\n\n4.  **Error Handling Tests:**\n    *   Simulate failure to fetch market price from the oracle.\n    *   Expected: The market order should be rejected with a clear error message, and no partial state changes should occur.",
      "status": "pending",
      "dependencies": [
        12,
        16
      ],
      "priority": "medium",
      "subtasks": []
    }
  ]
}