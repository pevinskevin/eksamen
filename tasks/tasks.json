{
  "tasks": [
    {
      "id": 1,
      "title": "BE: Project Setup & Basic Express Server",
      "description": "Initialize the Node.js backend project with Express.js. Set up project structure, linting (e.g., ESLint), formatting (e.g., Prettier), and a basic Express server that listens on a port. This forms the absolute foundation for all backend development.",
      "details": "Initialize a new Node.js project (`npm init -y`). Install Express (`npm install express`). Create a main server file (e.g., `server.js` or `app.js`) to set up a basic Express app: `const express = require('express'); const app = express(); const PORT = process.env.PORT || 3000; app.get('/', (req, res) => res.send('Exchange Backend Running')); app.listen(PORT, () => console.log(`Server running on port ${PORT}`));`. Set up scripts in `package.json` for starting the server (e.g., `dev` script using `nodemon`). Configure ESLint and Prettier for code consistency.",
      "testStrategy": "Verify that the Node.js project is initialized, Express is installed, and the basic server starts without errors, responding to a GET request at the root path. Linting and formatting tools should be configurable.",
      "priority": "high",
      "dependencies": [],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 2,
      "title": "BE: Database Selection & Initial Schema Design (Users, Cryptocurrencies, Balances)",
      "description": "Research and finalize the choice of database (leaning PostgreSQL as per PRD). Design the initial database schema for core entities: Users, Cryptocurrencies, Accounts (for fiat balances), and CryptoHoldings (for crypto balances). Implement migration scripts to create these tables.",
      "details": "Confirm PostgreSQL as the database. Install PostgreSQL locally or set up a cloud instance. Install the `pg` Node.js driver (`npm install pg`). Design schema: `Users` (user_id, email, password_hash, role, created_at, updated_at), `Cryptocurrencies` (cryptocurrency_id, symbol, name, description, is_active), `Accounts` (account_id, user_id FK, currency_code (e.g., 'SIM_USD'), balance DECIMAL, created_at, updated_at), `CryptoHoldings` (holding_id, user_id FK, cryptocurrency_id FK, balance DECIMAL, created_at, updated_at). Write SQL scripts or use a migration tool (e.g., `node-pg-migrate`) to create these tables.",
      "testStrategy": "Verify database connection from the Node.js application. Confirm that all specified tables and columns are created correctly in PostgreSQL with appropriate data types and constraints (primary keys, foreign keys, unique constraints).",
      "priority": "high",
      "dependencies": [
        1
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 3,
      "title": "BE: User Authentication Endpoints (Registration, Login)",
      "description": "Implement backend logic for user registration and login. This includes creating a User model, handling password hashing (e.g., using bcryptjs or argon2), storing user data, verifying credentials, and generating session tokens (JWT) or setting up cookie-based sessions.",
      "details": "Create `/auth/register` and `/auth/login` Express routes. For registration: validate input (email, password), hash password using `bcryptjs` (`npm install bcryptjs`), store user in `Users` table. For login: find user by email, compare hashed password, if valid, generate a JWT (`npm install jsonwebtoken`) containing user_id and role. Return token to client. Define User model functions for DB interactions (e.g., `createUser`, `findUserByEmail`).",
      "testStrategy": "Test registration endpoint: new user created in DB, password hashed. Test login endpoint: valid credentials return a token/session, invalid credentials return an error. Check token content.",
      "priority": "high",
      "dependencies": [
        2
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 4,
      "title": "BE: Authentication & Authorization Middleware",
      "description": "Implement middleware for session-based authentication to protect routes that require a logged-in user. The primary focus for this task is on implementing robust authentication middleware. Role-based authorization (e.g., admin/user distinctions) is deferred for now. Ownership-based access control, where necessary, will be handled within specific route handlers rather than a generic authorization middleware.",
      "status": "done",
      "dependencies": [
        3
      ],
      "priority": "high",
      "details": "Create an `authMiddleware` function. This function should:\n1. Check for an active session (e.g., by inspecting `req.session` and verifying the presence of `req.session.userId`).\n2. If a valid session exists (e.g., `req.session.userId` is present), ensure user information (e.g., user ID from `req.session.userId`, role from `req.session.role`) is readily accessible for subsequent handlers. This can be achieved by populating `req.user` (e.g., `req.user = { id: req.session.userId, role: req.session.role }`) or by ensuring route handlers can directly and reliably use `req.session` for this information.\n3. If authentication fails (no active session, or session data is invalid/missing required fields like `userId`), the middleware should send an appropriate error response (e.g., 401 Unauthorized).\n4. Apply this `authMiddleware` to all routes that require a user to be logged in.\nNote: General role-based authorization middleware (e.g., checking for 'admin' vs 'user' roles) is deferred. Specific access control logic, such as ownership checks, will be implemented directly within the relevant route handlers after authentication, using the user information made available by this session-based middleware.",
      "testStrategy": "1. Test that protected routes return a 401 Unauthorized status code when no active session is present (e.g., no session cookie sent, or session store does not recognize the session ID).\n2. Test that protected routes return a 401 Unauthorized status code when a session exists but is invalid or lacks essential user identifiers (e.g., `req.session.userId` is missing).\n3. Test that protected routes allow access (e.g., return a 2xx status code or proceed to the next handler) when a valid session with required user information (e.g., `req.session.userId`) is present.\n4. Verify that user information (e.g., `req.user` if populated, or directly via `req.session`) is correctly populated and accessible with user details (ID, role) after successful session validation.\n(Role-based authorization tests are deferred for this task).",
      "subtasks": []
    },
    {
      "id": 5,
      "title": "FE: Svelte Project Setup & Basic UI Shell",
      "description": "Set up the Svelte frontend project (or SvelteKit if preferred). Create a basic application shell with main layout components (e.g., navbar, footer, main content area) and set up client-side routing if using SvelteKit or a separate router.",
      "details": "Initialize a Svelte project: `npx degit sveltejs/template my-svelte-project` or `npm create svelte@latest my-sveltekit-project`. Set up basic folder structure (components, routes/pages, stores). Create `Navbar.svelte`, `Footer.svelte`, and an `App.svelte` or `+layout.svelte` to structure the main UI. If not using SvelteKit, install a router like `svelte-routing`.",
      "testStrategy": "Verify the Svelte application runs locally. Basic layout components should render. Navigation (if set up) should switch between placeholder pages.",
      "priority": "high",
      "dependencies": [],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 6,
      "title": "FE: User Authentication UI & Logic",
      "description": "Develop Svelte components for user registration and login forms. Implement logic to capture user input, perform client-side validation, and use the `fetch` API to send credentials to the backend authentication endpoints. Manage client-side user session (e.g., store JWT in localStorage, update UI based on auth state).",
      "details": "Create `Register.svelte` and `Login.svelte` components with input fields and submit buttons. Use Svelte stores (e.g., `writable`) for managing user authentication state (token, user info). On form submission, use `fetch` to POST to `/auth/register` or `/auth/login`. Handle responses: store token in localStorage on success, display errors on failure. Implement logout functionality (clear token, reset auth state). Conditionally render UI elements based on auth state (e.g., show Login/Register or Logout/Profile links).",
      "testStrategy": "User can register via the form, data sent to backend. User can log in, token received and stored. UI updates based on login status. Logout clears session. Error messages displayed for invalid input/credentials.",
      "priority": "high",
      "dependencies": [
        3,
        5
      ],
      "status": "done",
      "subtasks": [
        {
          "id": 1,
          "title": "Create Register.svelte Component",
          "description": "Develop the `Register.svelte` component, including form inputs for user registration (e.g., email, password, confirm password) and implement client-side validation logic for these inputs.",
          "dependencies": [],
          "details": "Form fields: username (optional), email, password, confirm password. Client-side validation: required fields, email format, password strength, password confirmation match. Display appropriate error messages.",
          "status": "done"
        },
        {
          "id": 2,
          "title": "Create Login.svelte Component",
          "description": "Develop the `Login.svelte` component, including form inputs for user login (e.g., email, password) and implement client-side validation logic.",
          "dependencies": [],
          "details": "Form fields: email, password. Client-side validation: required fields, email format. Display appropriate error messages.",
          "status": "done"
        },
        {
          "id": 3,
          "title": "Implement API Communication for Auth Endpoints",
          "description": "Implement `fetch` API calls from the Svelte components (or a dedicated service) to interact with the backend `/auth/register` and `/auth/login` endpoints. Handle request submission and response processing.",
          "dependencies": [
            1,
            2
          ],
          "details": "Functions to call `/auth/register` with registration data and `/auth/login` with login credentials. Handle success responses (e.g., receiving a JWT) and error responses (e.g., displaying backend error messages).",
          "status": "done"
        },
        {
          "id": 4,
          "title": "Manage Client-Side Authentication State",
          "description": "Implement mechanisms for managing the client-side authentication state. This includes storing the JWT (e.g., in `localStorage` or `sessionStorage`) upon successful authentication and using Svelte stores to make the authentication status and user data globally accessible.",
          "dependencies": [
            3
          ],
          "details": "Create a Svelte store (e.g., `authStore.js`) to hold user object and token. Functions to save token to localStorage, load token from localStorage on app init, and clear token. Update store based on login/registration success.",
          "status": "done"
        },
        {
          "id": 5,
          "title": "Implement Logout and Conditional UI Rendering",
          "description": "Implement logout functionality that clears the authentication state (JWT from storage, Svelte store). Update the UI to render conditionally based on the user's authentication status (e.g., show user profile/logout vs. login/register links).",
          "dependencies": [
            4
          ],
          "details": "Create a logout function/button that clears the token from localStorage and resets the auth store. Implement route guards or conditional rendering in Svelte components (`{#if $authStore.isAuthenticated}`) to protect routes and show/hide UI elements.",
          "status": "done"
        }
      ]
    },
    {
      "id": 7,
      "title": "BE: Cryptocurrency Management API & Seed Data",
      "description": "Create backend API endpoints for managing simulated cryptocurrencies (e.g., list all, get details). Implement a Cryptocurrency model and database interactions. Seed the database with initial cryptocurrency data (e.g., SIM_BTC, SIM_ETH).",
      "details": "Create a `/cryptocurrencies` GET endpoint in Express to list all active cryptocurrencies from the `Cryptocurrencies` table. Implement model functions for `Cryptocurrency` (e.g., `getAllCryptocurrencies`). Create a seed script (SQL or Node.js) to populate `Cryptocurrencies` table with initial data like: `('SIM_BTC', 'Simulated Bitcoin', 'A simulated version of Bitcoin for trading practice', true)`, `('SIM_ETH', 'Simulated Ethereum', 'A simulated version of Ethereum', true)`.",
      "testStrategy": "API endpoint `/cryptocurrencies` returns a JSON array of seeded cryptocurrencies. Data should match what's in the database.",
      "priority": "medium",
      "dependencies": [
        2
      ],
      "status": "done",
      "subtasks": [
        {
          "id": 1,
          "title": "Define/Update Cryptocurrency Database Model",
          "description": "Create or update the data model/schema for cryptocurrencies. This includes defining fields such as ID, name, symbol, current_price, and any other relevant attributes for database storage and interaction.",
          "dependencies": [],
          "details": "Specify data types, constraints (e.g., unique, not null), and relationships for the Cryptocurrency entity. This model will be used by the API and seeding script. Ensure it aligns with requirements for listing active cryptocurrencies.",
          "status": "done"
        },
        {
          "id": 2,
          "title": "Implement GET /cryptocurrencies API Endpoint",
          "description": "Develop a GET API endpoint (e.g., `/api/cryptocurrencies`) that retrieves and returns a list of all active cryptocurrencies from the database. This endpoint will use the Cryptocurrency model defined in subtask 1.",
          "dependencies": [
            1
          ],
          "details": "The endpoint should interact with the database to fetch all records from the `Cryptocurrencies` table. Ensure it returns data in a standard JSON format. Implement logic to filter for 'active' cryptocurrencies if this is a requirement.",
          "status": "done"
        },
        {
          "id": 3,
          "title": "Develop Cryptocurrency Data Seeding Script",
          "description": "Create a script (e.g., SQL, Node.js, or using an ORM's seeding mechanism) to populate the `Cryptocurrencies` table with initial sample data. This data will be used for development and testing the API.",
          "dependencies": [
            1
          ],
          "details": "The script should insert a predefined list of common cryptocurrencies (e.g., Bitcoin, Ethereum, Litecoin) with their respective details into the database, adhering to the model/schema defined in subtask 1. Include data for fields like name, symbol, and an initial price.",
          "status": "done"
        }
      ]
    },
    {
      "id": 8,
      "title": "FE: Display Cryptocurrencies",
      "description": "Develop a Svelte component to fetch and display the list of available cryptocurrencies from the backend. This list will be used for users to select which market to view/trade.",
      "details": "Create a `CryptoList.svelte` component. In its `onMount` lifecycle function or a load function (SvelteKit), use `fetch` to GET data from the `/cryptocurrencies` backend endpoint. Display the symbols and names in a list or table. Allow selection of a cryptocurrency (this will be used later for trading views).",
      "testStrategy": "The frontend correctly fetches and displays the list of cryptocurrencies obtained from the backend API. Selection mechanism should be testable.",
      "priority": "medium",
      "dependencies": [
        5,
        7
      ],
      "status": "done",
      "subtasks": [
        {
          "id": 1,
          "title": "Create CryptocurrencyList component structure",
          "description": "Create a new Svelte component to display the list of cryptocurrencies with basic structure and imports.",
          "details": "",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 8
        },
        {
          "id": 2,
          "title": "Implement API fetch logic for cryptocurrencies",
          "description": "Add function to fetch cryptocurrency data from the backend /api/crypto/cryptocurrencies endpoint using fetch API.",
          "details": "",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 8
        },
        {
          "id": 3,
          "title": "Create UI template for cryptocurrency display",
          "description": "Design and implement the HTML template to display cryptocurrency list with proper styling and layout.",
          "details": "",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 8
        }
      ]
    },
    {
      "id": 9,
      "title": "BE: Account & CryptoHolding Models & Balance API",
      "description": "Implement backend models for `Accounts` (fiat) and `CryptoHoldings` (crypto). Create API endpoints for authenticated users to fetch their balances. Implement logic to seed initial simulated fiat (e.g., SIM_USD) and/or crypto balances for new users upon registration or first login.",
      "details": "Create `/account/balances` GET endpoint, protected by auth middleware. This endpoint should query `Accounts` and `CryptoHoldings` tables for the logged-in user (`req.user.id`). Return a consolidated list of balances. Implement logic (e.g., during user registration or a separate seeding function) to give new users a starting amount of 'SIM_USD' in their `Accounts` table and potentially some base simulated crypto in `CryptoHoldings`.",
      "testStrategy": "Authenticated users can fetch their balances via the API. New users should have default seeded balances. Balances should reflect database state.",
      "priority": "high",
      "dependencies": [
        2,
        4
      ],
      "status": "done",
      "subtasks": [
        {
          "id": 1,
          "title": "Implement Account and CryptoHolding Database Models & Services",
          "description": "Define database schemas and implement service layer logic for `Accounts` (fiat) and `CryptoHoldings` (crypto).",
          "dependencies": [],
          "details": "This includes defining all necessary fields, relationships, data types, and basic CRUD operations for both models. `Accounts` will manage fiat currency balances (e.g., SIM_USD), and `CryptoHoldings` will manage cryptocurrency balances.",
          "status": "done"
        },
        {
          "id": 2,
          "title": "Create Authenticated GET API for User Balances",
          "description": "Develop an authenticated GET API endpoint (e.g., `/account/balances`) to fetch combined fiat and crypto balances for the logged-in user.",
          "dependencies": [
            1
          ],
          "details": "The endpoint must integrate with the authentication system. It will query the `Accounts` and `CryptoHoldings` data, aggregating balances for the specific user making the request.",
          "status": "done"
        },
        {
          "id": 3,
          "title": "Implement New User Initial Balance Seeding Logic",
          "description": "Develop the backend logic to automatically seed initial fiat (e.g., SIM_USD) and/or crypto balances for new users upon successful registration.",
          "dependencies": [
            1
          ],
          "details": "This logic should be triggered during the user registration process. Specify the default amounts and types of currencies/cryptocurrencies to be credited to new user accounts.\n<info added on 2025-05-24T15:54:51.474Z>\nUpon new user registration, only an initial fiat balance (SIM_USD 10000.00) will be seeded into the 'accounts' table. No initial cryptocurrency balances will be seeded. The existing implementation in `server/routers/authRouter.js` correctly handles this fiat seeding.\n</info added on 2025-05-24T15:54:51.474Z>",
          "status": "done"
        },
        {
          "id": 4,
          "title": "Ensure Correct User ID Filtering in Balance API Queries",
          "description": "Implement and verify that all API queries for fetching balances correctly join and filter data by `user_id` to ensure data integrity and security.",
          "dependencies": [
            2
          ],
          "details": "This involves rigorous testing of the `/account/balances` endpoint to confirm that it only returns data belonging to the authenticated user, preventing any cross-user data exposure. Review query construction for `Accounts` and `CryptoHoldings`.",
          "status": "done"
        }
      ]
    },
    {
      "id": 10,
      "title": "FE: Display Account Balances",
      "description": "Create Svelte components to display the authenticated user's fiat and cryptocurrency balances, fetched from the backend API.",
      "details": "Create an `AccountDashboard.svelte` or similar component. When the component mounts and the user is authenticated, use `fetch` to GET data from `/account/balances`. Display the balances clearly, separating fiat and different cryptocurrencies.",
      "testStrategy": "Logged-in user sees their correct fiat and crypto balances displayed. If no balances, an appropriate message is shown. Updates if balances change (e.g., after a trade, to be tested later).",
      "priority": "high",
      "dependencies": [
        6,
        9
      ],
      "status": "done",
      "subtasks": [
        {
          "id": 1,
          "title": "Create Account Dashboard Component Shell",
          "description": "Develop the basic structure for the `AccountDashboard.svelte` component (or equivalent for the chosen frontend framework). This component will serve as the container for displaying account balances.",
          "dependencies": [],
          "details": "Focus on creating the file, basic HTML/Svelte structure, and any necessary initial styling placeholders. No data fetching or display logic at this stage.",
          "status": "done"
        },
        {
          "id": 2,
          "title": "Implement Balance Fetching Logic",
          "description": "Implement the client-side logic to make authenticated API calls to the backend to retrieve the user's fiat and crypto account balances. This includes handling API responses and errors.",
          "dependencies": [
            1
          ],
          "details": "This logic might reside within the `AccountDashboard.svelte` component (e.g., in its script section or a lifecycle function) or in a separate service/store that the component consumes. Ensure proper handling of authentication tokens and API error states (e.g., network issues, unauthorized).",
          "status": "done"
        },
        {
          "id": 3,
          "title": "Display Balances in UI with Edge Case Handling",
          "description": "Integrate the fetched balance data into the `AccountDashboard.svelte` component's template. Clearly display the various fiat and crypto balances, and implement UI to handle cases such as zero balances, non-existent balances (if applicable), loading states, and error states from fetching.",
          "dependencies": [
            1,
            2
          ],
          "details": "Consider formatting for currency and cryptocurrency values. Implement user-friendly messages for loading, errors, or when no balances are available. Ensure the UI is responsive and accessible.",
          "status": "done"
        }
      ]
    },
    {
      "id": 11,
      "title": "BE: Order & Trade Models & DB Schema",
      "description": "Define and implement database schema for `Orders` and `Trades` within the existing `createDb.js` script. `Orders` will store user's buy/sell orders. `Trades` will record executed transactions between users.",
      "status": "done",
      "dependencies": [
        2
      ],
      "priority": "high",
      "details": "Extend DB schema by defining `Orders` and `Trades` tables within `createDb.js`. `Orders` (order_id PK, user_id FK, cryptocurrency_id FK, type ('buy'/'sell'), order_type ('limit'/'market'), quantity_total DECIMAL, quantity_remaining DECIMAL, price DECIMAL, status ('open', 'partially_filled', 'fully_filled', 'cancelled'), created_at, updated_at). `Trades` (trade_id PK, buy_order_id FK, sell_order_id FK, cryptocurrency_id FK, quantity DECIMAL, price DECIMAL, buyer_user_id FK, seller_user_id FK, trade_timestamp). The `createDb.js` script will handle schema creation, dropping, and resetting; formal versioned migration tool integration is not planned for this task.",
      "testStrategy": "Verify `Orders` and `Trades` tables are created correctly in the database with all specified fields and constraints by running the `createDb.js` script. Ensure the script can successfully drop and recreate these tables.",
      "subtasks": []
    },
    {
      "id": 12,
      "title": "BE: Order Placement API (Limit Orders)",
      "description": "Implement a backend API endpoint for users to place new buy or sell orders, supporting both 'limit' and 'market' order types as per the updated request structure. This endpoint must validate the order through a 4-layer architecture (Input Validation, Business Rules Validation, Balance Validation, Error Handling) and, if valid, store it in the `Orders` table with an 'open' status. The request structure is { cryptocurrency_id, type, order_type, quantity, price (optional for market orders) }.",
      "status": "done",
      "dependencies": [
        4,
        9,
        11,
        "31",
        "32",
        "33"
      ],
      "priority": "high",
      "details": "Create `POST /orders` endpoint (as per REST conventions, protected by auth middleware). \nRequest body: `{ cryptocurrency_id: int, type: 'buy'/'sell', order_type: 'limit'/'market', quantity: float, price: float (required for 'limit' orders, optional for 'market' orders) }`.\n\nBackend Logic (4-Layer Validation Architecture):\n1.  **Layer 1: Input Validation (No Database Calls)**: Validate data types, required fields (price is conditional on `order_type`), and formats (e.g., positive numbers for quantity/price, valid enum values for type/order_type).\n2.  **Layer 2: Business Rules Validation (Lightweight DB Calls)**: Check `cryptocurrency_id` existence in the `cryptocurrencies` table. Basic validation of quantity/price (e.g. positive values, though primarily handled in Layer 1).\n3.  **Layer 3: Balance Validation (Critical Financial Check)**:\n    *   If 'buy' order: Check user's SIM_USD balance in the `accounts` table. For limit orders, ensure `balance >= quantity * price`. (Market order cost estimation for balance check needs separate clarification if fully implemented under this task).\n    *   If 'sell' order: Check user's relevant cryptocurrency balance in the `crypto_holdings_base` table, ensuring `crypto_balance >= quantity`.\n4.  **Order Creation**: If all validations pass, create a new record in the `Orders` table with status 'open', `quantity_remaining = quantity_total`, and include `order_type`.\n5.  **Layer 4: Error Handling & Response**: Respond with success or a standardized JSON error (using HTTP status codes like 400, 422, 500) providing detailed messages.",
      "testStrategy": "Authenticated users can submit valid limit and market orders. Orders are stored correctly in the DB, including `order_type` and appropriate `price` (null for market if not provided). \nLayer 1 Validations: Test rejections for invalid data types, missing required fields (e.g., price for limit order, or `order_type`), invalid enum values, non-positive quantity/price. \nLayer 2 Validations: Test rejections for non-existent `cryptocurrency_id`. \nLayer 3 Validations: Test rejections for insufficient SIM_USD (buy orders) or crypto (sell orders) balance. Verify correct tables (`accounts`, `crypto_holdings_base`) are checked. \nLayer 4 Validations: Ensure standardized JSON error responses with correct HTTP status codes (400, 422, 500) for all failure scenarios. Test successful order placement for both 'buy' and 'sell' types, and for 'limit' and 'market' order types.",
      "subtasks": [
        {
          "id": 1,
          "title": "Define POST /orders/ Endpoint and Basic Structure",
          "description": "Create the Express route for `POST /orders/`. Integrate existing authentication middleware to protect the endpoint. Set up the basic request handler structure within the appropriate Express router.",
          "dependencies": [],
          "details": "This involves: 1. Locating or creating the relevant Express router file (e.g., `orderRoutes.js`). 2. Defining the `POST /orders/` route, adhering to RESTful conventions. 3. Applying the project's standard authentication middleware to this route. 4. Creating an initial placeholder controller/handler function for this route.\n<info added on 2025-05-25T15:00:29.180Z>\nUsing RESTful POST /orders/ endpoint instead of /orders/place as this follows proper REST conventions. The basic structure is already in place in orderRouter.js with authentication middleware applied.\n</info added on 2025-05-25T15:00:29.180Z>",
          "status": "done"
        },
        {
          "id": 2,
          "title": "Implement Layer 1 & 2 Validation (Input & Business Rules)",
          "description": "Develop and integrate server-side validation for the order placement request body, covering Layer 1 (Input Validation - no DB calls) and Layer 2 (Business Rules Validation - lightweight DB calls). This includes `cryptocurrency_id`, `type`, `order_type`, `quantity`, and `price`.",
          "dependencies": [
            1
          ],
          "details": "This involves:\n**Layer 1: Input Validation (No Database Calls)**\n1.  Validate data types for all fields: `cryptocurrency_id` (integer), `type` (string), `order_type` (string), `quantity` (number), `price` (number, if present).\n2.  Validate required fields: `cryptocurrency_id`, `type`, `order_type`, `quantity` are always required.\n3.  Conditional `price` validation: `price` is required if `order_type` is 'limit'; optional if `order_type` is 'market'. If provided for market, it might be ignored or used as a ceiling, per system design.\n4.  Validate enum values: `type` must be 'buy' or 'sell'. `order_type` must be 'limit' or 'market'.\n5.  Validate numeric formats: `quantity` must be a positive number. `price` (if provided) must be a positive number. Adhere to any precision/min/max rules.\n\n**Layer 2: Business Rules Validation (Lightweight DB Calls)**\n1.  Validate `cryptocurrency_id`: Ensure it exists in the `cryptocurrencies` table.\n2.  Basic quantity/price validation (e.g., positive values) - primarily covered in Layer 1, re-verify if any DB-dependent rules apply here (e.g., lot sizes, tick sizes if defined).\n\nEnsure validation errors from both layers lead to appropriate early responses (e.g., HTTP 400 Bad Request or 422 Unprocessable Entity).",
          "status": "done"
        },
        {
          "id": 3,
          "title": "Implement Layer 3: Balance Validation",
          "description": "Create logic for Layer 3 (Balance Validation) to check the authenticated user's available balance. For 'buy' orders, check SIM_USD balance in the `accounts` table. For 'sell' orders, check the relevant cryptocurrency balance in the `crypto_holdings_base` table.",
          "dependencies": [
            2
          ],
          "details": "This involves:\n1.  Retrieving the authenticated user's ID (from the auth middleware).\n2.  For 'buy' orders:\n    a.  Query the `accounts` table for the user's available SIM_USD balance.\n    b.  If `order_type` is 'limit', ensure `available_SIM_USD_balance >= quantity * price`.\n    c.  If `order_type` is 'market', the mechanism for determining the funds to hold (e.g., based on quantity and current market price or a buffer) needs to be defined. For this task, prioritize limit order logic.\n3.  For 'sell' orders:\n    a.  Query the `crypto_holdings_base` table for the user's available balance of the specified `cryptocurrency_id`.\n    b.  Ensure `available_crypto_balance >= quantity`.\n4.  Ensure the balance check considers only *available* funds (e.g., not funds locked in other open orders).\n5.  This logic is critical and should be callable from the order placement handler after Layer 1 and Layer 2 validations pass. If balance is insufficient, respond with an appropriate error (e.g., HTTP 400 or 422).",
          "status": "done"
        },
        {
          "id": 4,
          "title": "Implement Order Creation in PostgreSQL Database",
          "description": "If all validations (Layers 1-3) pass and the user has sufficient funds, implement the logic to create a new order record in the `Orders` table in the PostgreSQL database with an initial status of 'open'. Include `order_type` in the stored record.",
          "dependencies": [
            3
          ],
          "details": "This involves:\n1.  Constructing the data object for the new order, including `user_id`, `cryptocurrency_id`, `type` (buy/sell), `order_type` (limit/market), `quantity_total` (from request `quantity`), `price` (from request `price` for limit orders; can be null for market orders if not provided or not applicable at creation), `status` ('open'), and `quantity_remaining` (initially equal to `quantity_total`), `created_at` (timestamp).\n2.  Using the project's database access layer (e.g., ORM, query builder, or raw SQL client) to insert the new record into the `Orders` table.\n3.  Ensure the operation is robust. Consider if this operation should be part of a larger transaction if funds are to be locked/deducted simultaneously (though fund movement might be handled by a separate ledger service or subsequent step).",
          "status": "done"
        },
        {
          "id": 5,
          "title": "Implement Layer 4: Error Handling and Response Formatting",
          "description": "Ensure robust error handling throughout the order placement process as per Layer 4. Provide clear, standardized JSON error responses for various failure scenarios, using appropriate HTTP status codes (e.g., 400, 422, 500).",
          "dependencies": [
            2,
            3,
            4
          ],
          "details": "This involves:\n1.  Defining or adhering to a project-wide standardized JSON error response format (e.g., `{ \"error\": { \"message\": \"...\", \"code\": \"...\" } }`).\n2.  Handling errors from Layer 1 & 2 (Input and Business Rule Validation) with HTTP 400 (Bad Request) or HTTP 422 (Unprocessable Entity) for client-side errors. Include detailed messages indicating which field or rule failed.\n3.  Handling errors from Layer 3 (Balance Validation - e.g., insufficient funds) with an appropriate HTTP status (e.g., HTTP 400 or 422), with a clear message.\n4.  Handling potential errors during database interaction (Order Creation in Subtask 4) with HTTP 500 (Internal Server Error) for unexpected server-side issues.\n5.  Ensuring all success responses (e.g., HTTP 201 Created for new order) also follow a consistent format, returning relevant information about the created order.",
          "status": "done"
        }
      ]
    },
    {
      "id": 13,
      "title": "FE: Trading Form & My Open Orders Display",
      "description": "Develop Svelte components for a trading form (select crypto, buy/sell, quantity, price) and a display area for the user's currently open orders. Orders submitted via the form should be sent to the backend API.",
      "details": "Create `TradingForm.svelte` component. Inputs for cryptocurrency selection (dropdown populated from crypto list), order type (buy/sell buttons), quantity, price. On submit, `fetch` POST to `/orders/place`. Create `MyOpenOrders.svelte` component. Fetch user's open orders from a new backend endpoint (e.g., `/orders/mine`) and display them in a table.",
      "testStrategy": "User can fill and submit the trading form. Order data is sent to backend. User's open orders are fetched and displayed correctly. Client-side validation for form inputs.",
      "priority": "high",
      "dependencies": [
        6,
        8,
        10,
        12,
        "31",
        "32",
        "33"
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 14,
      "title": "BE: WebSocket Server Integration",
      "description": "Integrate a WebSocket server (e.g., `ws` library or `socket.io`) into the Express backend. Handle basic client connections and disconnections.",
      "details": "Install `ws` (`npm install ws`). Integrate with existing HTTP server: `const WebSocket = require('ws'); const server = http.createServer(app); const wss = new WebSocket.Server({ server }); wss.on('connection', ws => { console.log('Client connected'); ws.on('message', message => console.log('received: %s', message)); ws.on('close', () => console.log('Client disconnected')); }); server.listen(PORT, ...);`. This sets up the WebSocket server alongside Express.",
      "testStrategy": "WebSocket server starts with the HTTP server. Client can connect to the WebSocket endpoint. Connection/disconnection events are logged on the server.",
      "priority": "high",
      "dependencies": [
        1
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 15,
      "title": "FE: WebSocket Client Integration",
      "description": "Implement Socket.IO client logic in the Svelte frontend to connect to the backend Socket.IO server. Handle connection establishment and receive 'orderBookUpdate' events containing Binance market data.",
      "status": "done",
      "dependencies": [
        5,
        14
      ],
      "priority": "high",
      "details": "Integrate the Socket.IO client library (`socket.io-client`) into the Svelte frontend. In a Svelte store or a suitable client-side component (e.g., `+layout.svelte` or a dedicated service), establish a Socket.IO connection: `import { io } from 'socket.io-client'; const socket = io('http://localhost:8080'); socket.on('connect', () => console.log('Connected to Socket.IO server')); socket.on('disconnect', () => console.log('Disconnected from Socket.IO server')); socket.on('orderBookUpdate', (data) => console.log('Order book update:', data));`. Ensure this runs client-side. The backend already logs user connections/disconnections, so frontend logging for these events is primarily for client-side debugging.",
      "testStrategy": "Svelte frontend successfully connects to the backend Socket.IO server at 'http://localhost:8080'. Console logs confirm connection. Verify that 'orderBookUpdate' events are received and that the payload contains Binance market data. Backend logs should also show client connection/disconnection.",
      "subtasks": [
        {
          "id": 1,
          "title": "Install socket.io-client library",
          "description": "Install the socket.io-client library in the frontend project to enable Socket.IO communication.",
          "details": "",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 15
        },
        {
          "id": 2,
          "title": "Create Socket.IO store structure",
          "description": "Create socketStore.js with writable stores for socket connection, connection status, and order book data. Include connectSocket and disconnectSocket functions.",
          "details": "",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 15
        },
        {
          "id": 3,
          "title": "Implement connection and disconnect event listeners",
          "description": "Add event listeners for 'connect' and 'disconnect' events, logging connection status to the browser console and updating the isConnected store.",
          "details": "",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 15
        },
        {
          "id": 4,
          "title": "Implement orderBookUpdate event listener",
          "description": "Add event listener for 'orderBookUpdate' events, logging the received Binance market data to the browser console and updating the orderBookData store.",
          "details": "",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 15
        }
      ]
    },
    {
      "id": 16,
      "title": "BE: In-Memory Order Book Implementation",
      "description": "Integrate with the Binance WebSocket API to maintain a real-time local copy of the Binance order book for each cryptocurrency pair. Layer user-placed orders on top of this live Binance data. Implement logic to manage the lifecycle of these user orders (add, cancel, fill) and a matching engine that can match user orders against the live Binance price levels or against other user orders within our system. This creates a hybrid order book where Binance acts as the primary market maker and price discovery mechanism, while our platform manages its users' orders and internal matching opportunities. Refer to `binance-ws.js` as the module to extend for Binance integration and `depthcache-documentation.md` for general order book concepts if still relevant.",
      "status": "pending",
      "dependencies": [
        11,
        12
      ],
      "priority": "high",
      "details": "1. Extend `binance-ws.js` to subscribe to Binance's depth WebSocket streams (e.g., `bnbbtc@depth`) and maintain an in-memory, synchronized copy of the Binance order book (bids and asks).\n2. Create an `OrderBookService.js` (or similar module) to manage this hybrid system. This service will:\n    a. Consume the live Binance order book data from `binance-ws.js`.\n    b. Manage user-placed orders (buy/sell orders from `/orders/place`), storing their price, quantity, timestamp, order_id, and status (pending, partially_filled, filled, cancelled). These user orders are *not* sent to Binance.\n    c. Present a 'hybrid' view of the order book, where user orders are layered on top of Binance's data. For example, if a user's bid is higher than Binance's best bid, it becomes the effective best bid for our system.\n3. Implement matching logic within a `MatchingEngine` module (or as part of the `OrderBookService`) that:\n    a. Attempts to match incoming user orders against other existing user orders if a favorable price (better than or equal to Binance's) is available (user-to-user match).\n    b. If no user-to-user match is possible or favorable, attempts to match user orders against the live Binance order book (user-to-Binance 'fill'). This means if a user places a market buy, it would fill against Binance's asks; if a limit buy is at or above Binance's best ask, it would fill.\n    c. Manages the lifecycle of user orders based on matching outcomes (e.g., updating quantity for partial fills, changing status for full fills).\n4. User orders should maintain price-time priority. The `depthcache-documentation.md` might offer general insights, but the primary source for Binance integration will be their API documentation.",
      "testStrategy": "1. Verify `binance-ws.js` correctly subscribes to and synchronizes with Binance depth streams, accurately reflecting the Binance order book locally. Test handling of snapshots and differential updates.\n2. Test placement of user orders: ensure they are correctly stored and layered onto the local Binance book data, forming the hybrid order book. Verify price-time priority for user orders.\n3. Test user order lifecycle: cancellation, partial fills, and full fills, ensuring status and quantity are updated correctly.\n4. Test matching logic:\n    a. User-to-user matches: Verify that if two user orders can cross, they are matched internally.\n    b. User-to-Binance matches: Verify user orders are correctly matched against the Binance book (e.g., a user market buy order fills at Binance's ask prices; a user limit buy order above Binance's best ask fills).\n5. Verify the hybrid order book queries (best bid/ask, depth) accurately reflect the combination of Binance data and active user orders.",
      "subtasks": [
        {
          "id": 1,
          "title": "Design Hybrid Order Book Data Structures",
          "description": "Define data structures for: a) Storing a real-time local copy of the Binance order book (synced via WebSocket). b) Managing active user orders. c) Representing a combined 'effective' order book view for matching and queries.",
          "dependencies": [],
          "details": "For (a), consider efficient application of depth updates (diffs/snapshots) from Binance. For (b), ensure price-time priority for user orders. For (c), specify how user orders are layered onto Binance data to determine best bids/asks and available liquidity at various price levels. Document choices for performance and consistency.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Implement User Order Placement Logic",
          "description": "Implement functionality to accept and store new user orders (buy/sell). These orders are managed locally within our system and are not sent directly to Binance.",
          "dependencies": [
            1
          ],
          "details": "Upon placement, a user order should be validated and added to the local user order management system. It will then be considered by the matching engine against the hybrid order book. Ensure price-time priority is maintained for user orders at the same price level.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Implement User Order Lifecycle Management (Cancel, Modify)",
          "description": "Implement logic for managing the lifecycle of user orders: cancellation by user, and modification (e.g., quantity update due to partial fills by the matching engine). This applies only to user orders.",
          "dependencies": [
            1,
            2
          ],
          "details": "Ensure user order cancellations are processed correctly, removing them from active consideration by the matching engine. Handle partial fills by updating the remaining quantity of the user order. Fully filled orders should be marked appropriately.",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Implement Hybrid Order Book Query Functions",
          "description": "Develop functions to query the current state of the *hybrid* order book. This includes retrieving the best bid/ask, spread, and order book depth, considering both Binance data and active user orders.",
          "dependencies": [
            1,
            2,
            6
          ],
          "details": "These functions will be used by the matching engine and potentially for UI display. Queries must reflect the combined view: e.g., if a user's bid is higher than Binance's best bid, it becomes the system's effective best bid. Optimize for read performance.",
          "status": "pending"
        },
        {
          "id": 5,
          "title": "Develop Hybrid Order Book Service/Module",
          "description": "Develop or extend an `OrderBookService` to encapsulate all functionalities: managing the local Binance order book copy, managing user orders, and providing an interface for the matching engine and other system components.",
          "dependencies": [
            1,
            2,
            3,
            4,
            6
          ],
          "details": "This service will consume updates from `binance-ws.js` (for Binance book), manage user order state changes (add, cancel, fill), and expose APIs for querying the hybrid book and submitting user orders. Consider thread-safety if concurrent access is expected.",
          "status": "pending"
        },
        {
          "id": 6,
          "title": "Extend `binance-ws.js` for Binance Order Book Synchronization",
          "description": "Modify `binance-ws.js` to subscribe to Binance's depth WebSocket streams (e.g., `bnbbtc@depth` or `bnbbtc@depth@100ms`) for relevant trading pairs. Implement logic to maintain an accurate, real-time local copy of the Binance order book.",
          "dependencies": [
            1
          ],
          "details": "Handle initial snapshot and subsequent differential updates from Binance. Ensure data structures for the local Binance book are efficient for updates and reads. Refer to Binance API documentation for depth stream details (e.g., managing sequence numbers for diffs).",
          "status": "pending"
        },
        {
          "id": 7,
          "title": "Implement Hybrid Order Matching Logic",
          "description": "Develop the matching engine logic that operates on the hybrid order book. It should be able to match user orders against the live Binance order book levels and against other user orders if a better price is available internally.",
          "dependencies": [
            5
          ],
          "details": "Matching priorities: 1. User vs. User (if price is better than or equal to Binance). 2. User vs. Binance. Implement price-time priority for user orders. When a user order is matched against Binance, it's conceptually 'executed' at Binance's price. When matched user-to-user, it's an internal settlement.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 17,
      "title": "BE: Order Matching Engine Development",
      "description": "Develop the core order matching engine logic for a hybrid system. The engine will first attempt to match incoming user orders against other resting user orders (user-to-user matching) based on price-time priority, especially if better prices are available than on Binance. Subsequently, it will attempt to match any remaining quantity against live Binance order book data (user-to-Binance execution). The engine must handle a hybrid order book combining user orders with Binance data and manage partial/full fills. Refer to `depthcache-documentation.md` for general matching strategies and `binance-ws.js` for Binance integration.",
      "status": "pending",
      "dependencies": [
        16
      ],
      "priority": "high",
      "details": "To be implemented in `OrderBookService.js` or a dedicated `MatchingEngine.js`.\nThe matching process for an incoming order:\n1.  **User-to-User Matching:**\n    *   Attempt to match against the local book of user orders.\n    *   If buy order, iterate through user asks (lowest price first).\n    *   If sell order, iterate through user bids (highest price first).\n    *   Prioritize these matches if user order prices are better than or equal to the best available Binance price for the user.\n    *   Price-time priority for user orders: match best price first; if multiple user orders at best price, match oldest first (FIFO based on timestamp).\n2.  **User-to-Binance Matching:**\n    *   If the incoming order is not fully matched against user orders, or if Binance offers a better price for the user, attempt to match the remaining quantity against the Binance order book.\n    *   Utilize real-time Binance order book data provided by the extended `binance-ws.js`.\n    *   Trades matched against Binance liquidity are executed at Binance prices.\n3.  **Hybrid Order Book Management:**\n    *   The engine must operate on a conceptual hybrid order book that layers user orders on top of or integrates them with Binance's market depth for matching decisions.\n4.  **Fill Logic:**\n    *   Determine fill quantity (min of incoming order quantity and resting order/Binance liquidity quantity).\n    *   If partial fill, update remaining quantity of the involved order(s).\n    *   If full fill, mark user order(s) for removal or reflect consumption of Binance liquidity.\n    *   An incoming order can be matched against multiple user orders and/or Binance liquidity.",
      "testStrategy": "Test various scenarios:\n1.  **User-to-User Matches:**\n    *   New buy order matching existing user sell order(s) at prices better than Binance.\n    *   New sell order matching existing user buy order(s) at prices better than Binance.\n    *   Verify price-time priority for user orders (best price first, then FIFO for same price).\n2.  **User-to-Binance Matches:**\n    *   New buy order matching Binance asks when no better user sell orders exist or Binance price is superior.\n    *   New sell order matching Binance bids when no better user buy orders exist or Binance price is superior.\n    *   Verify execution at Binance prices.\n3.  **Hybrid Matching Scenarios:**\n    *   Incoming order partially filled by user orders, then remaining quantity filled by Binance liquidity.\n    *   Incoming order where Binance offers a better price than available user orders, leading to direct matching with Binance liquidity.\n    *   Scenarios where user orders are placed within the Binance spread.\n4.  **Fill Logic:**\n    *   Test partial fills, multiple fills for one incoming order (across user and Binance liquidity).\n    *   Test orders that don't match and get added to the user order book.\n5.  **Integration & Order Book Integrity:**\n    *   Verify correct interaction with `binance-ws.js` for fetching and using Binance order book data.\n    *   Verify the hybrid order book logic correctly prioritizes and matches orders.\n    *   Ensure user orders are correctly added to, updated in, and removed from the local order book.",
      "subtasks": [
        {
          "id": "subtask_17_1",
          "title": "Design matching engine for hybrid (user + Binance) model",
          "status": "pending",
          "description": "Define the architecture of the matching engine to support a two-phase matching process (user-to-user, then user-to-Binance) and manage a hybrid order book."
        },
        {
          "id": "subtask_17_2",
          "title": "Implement user-to-user matching logic",
          "status": "pending",
          "description": "Develop the functionality to match incoming user orders against resting user orders. Prioritize these matches if user order prices are better than or equal to Binance's. Implement price-time priority for user orders."
        },
        {
          "id": "subtask_17_3",
          "title": "Integrate with binance-ws.js for Binance order book data",
          "status": "pending",
          "description": "Consume real-time Binance order book data from `binance-ws.js`. This data will serve as the external market liquidity layer."
        },
        {
          "id": "subtask_17_4",
          "title": "Implement user-to-Binance matching logic",
          "status": "pending",
          "description": "Develop the functionality to match remaining quantities of user orders (or orders where Binance offers a better price) against Binance liquidity. Ensure trades are marked for execution at Binance prices."
        },
        {
          "id": "subtask_17_5",
          "title": "Implement hybrid fill and order management logic",
          "status": "pending",
          "description": "Handle partial and full fills for orders, considering that a single incoming order might be matched against multiple user orders and/or Binance liquidity. Update user order book state accordingly."
        },
        {
          "id": "subtask_17_6",
          "title": "Develop hybrid order book representation and management",
          "status": "pending",
          "description": "Ensure the matching engine can effectively view and operate on a combined representation of local user orders and Binance market depth, making correct priority decisions."
        }
      ]
    },
    {
      "id": 18,
      "title": "BE: Trade Execution & State Updates",
      "description": "Implement the backend logic for trade execution when a match is found by the matching engine. This system must handle two distinct scenarios:\n1.  **User-to-User Trades:** Traditional exchange behavior where two user orders are matched. This involves atomically updating balances for both users (debit/credit fiat and crypto), creating a `Trade` record, and updating the status of both involved `Order` records in the database and in-memory order book.\n2.  **User-to-Binance Executions:** User orders are matched against Binance's external liquidity. This involves atomically updating only the participating user's balances, creating a `Trade` record that reflects Binance as the counterparty, and updating the user's `Order` record.\n\nAtomicity of database operations is critical for both scenarios.",
      "status": "pending",
      "dependencies": [
        9,
        11,
        17
      ],
      "priority": "high",
      "details": "The core responsibility is to process matched trades, whether they are internal User-to-User trades or external User-to-Binance executions. This involves atomic database updates for user balances, trade record creation, and order status management in both the database and the in-memory order book.\n\n**Key Requirements:**\n1.  **Differentiate Trade Types:** The system must distinguish between:\n    *   **User-to-User Trades:** Matches between two orders from users on our platform.\n    *   **User-to-Binance Executions:** Matches where a user's order is filled against Binance's liquidity.\n2.  **Atomicity:** All database operations for a single trade (balance updates, trade creation, order updates) must be performed within a single transaction to ensure data consistency.\n3.  **Trade Record:** A comprehensive `Trade` record must be created for every execution, indicating the type of trade.\n4.  **Order Updates:** Involved `Order` records must be updated (status, quantity remaining) in the database and reflected in the in-memory order book.\n\n**Detailed Process:**\n\n**I. Pre-Execution:**\n    1.  Upon receiving a match from the matching engine, determine if it's a User-to-User trade or a User-to-Binance execution.\n    2.  Start a database transaction.\n\n**II. User-to-User Trade Execution:**\n    1.  **Identify Parties:** Buyer user and Seller user.\n    2.  **Fiat Balances:**\n        *   Debit buyer's fiat account.\n        *   Credit seller's fiat account.\n    3.  **Crypto Balances:**\n        *   Debit seller's crypto holdings (for the traded crypto).\n        *   Credit buyer's crypto holdings (for the traded crypto).\n    4.  **Database Updates:** Persist changes to `Accounts` and `CryptoHoldings` tables for both users.\n    5.  **Trade Record Creation:** Create a new record in the `Trades` table.\n        *   Fields: `buyer_id` (buyer user's ID), `seller_id` (seller user's ID), `crypto_id`, `quantity`, `price`, `timestamp`, `trade_type` (e.g., 'USER_TO_USER').\n    6.  **Order Updates (Database):** For both the buyer's and seller's orders:\n        *   Update status (e.g., 'PARTIALLY_FILLED', 'FILLED').\n        *   Decrease `quantity_remaining`.\n    7.  **Order Updates (In-Memory):** Update or remove the corresponding orders from the in-memory order book.\n\n**III. User-to-Binance Trade Execution:**\n    1.  **Identify Party:** The user whose order is matched against Binance.\n    2.  **Balance Updates (User only):**\n        *   **If user is BUYING from Binance:**\n            *   Debit user's fiat account.\n            *   Credit user's crypto holdings.\n        *   **If user is SELLING to Binance:**\n            *   Credit user's fiat account.\n            *   Debit user's crypto holdings.\n    3.  **Database Updates:** Persist changes to the user's `Accounts` and `CryptoHoldings` tables.\n    4.  **Trade Record Creation:** Create a new record in the `Trades` table.\n        *   Fields:\n            *   If user buys: `buyer_id` (user's ID), `seller_id` (a designated system account ID for Binance).\n            *   If user sells: `seller_id` (user's ID), `buyer_id` (a designated system account ID for Binance).\n            *   Common fields: `crypto_id`, `quantity`, `price`, `timestamp`, `trade_type` (e.g., 'USER_TO_BINANCE').\n    5.  **Order Updates (Database):** For the user's order:\n        *   Update status (e.g., 'PARTIALLY_FILLED', 'FILLED').\n        *   Decrease `quantity_remaining`.\n    6.  **Order Updates (In-Memory):** Update or remove the user's order from the in-memory order book.\n\n**IV. Post-Execution (Common for both types):**\n    1.  **Commit Transaction:** If all operations succeed, commit the database transaction.\n    2.  **Rollback on Failure:** If any operation fails, roll back the entire transaction.\n    3.  **Event Emission:** Emit events (e.g., `TradeExecuted`, `BalanceUpdated`) to notify other services or for auditing.",
      "testStrategy": "The test strategy must cover both User-to-User and User-to-Binance trade scenarios.\n\n1.  **User-to-User Trade Verification:**\n    *   Verify that after a trade, the buyer's fiat is debited, and crypto is credited correctly in the database.\n    *   Verify that the seller's fiat is credited, and crypto is debited correctly in the database.\n    *   Verify a `Trade` record is created with correct `buyer_id`, `seller_id`, `trade_type`='USER_TO_USER', and other trade details.\n    *   Verify that both involved `Order` statuses and `quantity_remaining` are correctly updated in the database.\n    *   Verify that both orders are correctly updated/removed from the in-memory order book.\n2.  **User-to-Binance Trade Verification:**\n    *   **User Buys from Binance:**\n        *   Verify user's fiat is debited, and crypto is credited correctly.\n        *   Verify no other internal user's balance is affected.\n        *   Verify `Trade` record with user as `buyer_id`, Binance system account as `seller_id`, and `trade_type`='USER_TO_BINANCE'.\n    *   **User Sells to Binance:**\n        *   Verify user's fiat is credited, and crypto is debited correctly.\n        *   Verify no other internal user's balance is affected.\n        *   Verify `Trade` record with user as `seller_id`, Binance system account as `buyer_id`, and `trade_type`='USER_TO_BINANCE'.\n    *   For both buy/sell scenarios with Binance:\n        *   Verify the user's `Order` status and `quantity_remaining` are correctly updated in the database.\n        *   Verify the user's order is correctly updated/removed from the in-memory order book.\n3.  **Atomicity Tests:**\n    *   Simulate failures at various points during the trade execution process (e.g., after debiting one user but before crediting another, or before creating the trade record).\n    *   Verify that the entire transaction is rolled back, and the system state remains consistent (no partial updates to balances or orders). This applies to both trade types.\n4.  **Concurrency Tests:**\n    *   Test concurrent trade executions to ensure data integrity and absence of race conditions.\n5.  **Edge Cases:**\n    *   Partial fills for both trade types.\n    *   Trades involving very small or very large quantities/prices.",
      "subtasks": [
        {
          "id": "18_S1",
          "title": "Define/Update `Trades` table schema to include `trade_type` (e.g., 'USER_TO_USER', 'USER_TO_BINANCE') and establish a method for representing Binance as a counterparty (e.g., using a designated system account ID in `buyer_id`/`seller_id` fields).",
          "status": "pending"
        },
        {
          "id": "18_S2",
          "title": "Implement trade execution service entry point that accurately determines if a match corresponds to a User-to-User trade or a User-to-Binance execution.",
          "status": "pending"
        },
        {
          "id": "18_S3",
          "title": "Implement User-to-User trade execution logic, including: atomic balance updates for both users (fiat and crypto), creation of `Trade` record with `trade_type`='USER_TO_USER', update of both `Order` records (DB and in-memory).",
          "status": "pending"
        },
        {
          "id": "18_S4",
          "title": "Implement User-to-Binance trade execution logic, including: atomic balance updates for the single user (fiat and crypto), creation of `Trade` record with `trade_type`='USER_TO_BINANCE' and Binance as counterparty, update of the user's `Order` record (DB and in-memory).",
          "status": "pending"
        },
        {
          "id": "18_S5",
          "title": "Implement robust database transaction management covering all trade execution paths (User-to-User and User-to-Binance) to ensure atomicity of operations.",
          "status": "pending"
        },
        {
          "id": "18_S6",
          "title": "Implement event emission for successful trades (e.g., `TradeExecutedEvent`, `BalanceUpdatedEvent`) for both User-to-User and User-to-Binance trade types.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 19,
      "title": "BE: Real-time Order Book Broadcasting",
      "description": "Implement a real-time broadcasting system for a hybrid order book. This hybrid order book combines user orders (local internal orders from platform users) and Binance order book data (external market liquidity). When changes occur (user order added/cancelled/filled, trade executed, or Binance data updates), the system must broadcast the complete hybrid order book state via WebSockets to all connected and subscribed frontend clients. This ensures transparency, allowing users to see both internal order activity and external market liquidity, potentially in a layered display.",
      "status": "pending",
      "dependencies": [
        14,
        16,
        18
      ],
      "priority": "high",
      "details": "1. **Hybrid Order Book Construction:**\n    *   Develop logic within `OrderBookService.js` or a new dedicated module to construct and maintain the hybrid order book.\n    *   This involves integrating local user orders with real-time data fetched from the Binance order book (e.g., via Task 18: BE: Binance Order Book Integration).\n    *   The broadcast data should facilitate a layered display where user orders are visible alongside or integrated with Binance market depth.\n\n2.  **Triggering Updates:**\n    *   The system must react to changes from multiple sources:\n        *   Local user order events: new order, cancellation, fill (partial or full) from `User Order Management` (Task 16).\n        *   Internal trade executions from the `MatchingEngine.js`.\n        *   Updates from the Binance order book data stream (Task 18).\n\n3.  **Broadcasting Mechanism:**\n    *   Utilize the WebSocket infrastructure (Task 14: BE: WebSocket Setup).\n    *   After any relevant change, serialize the *complete current state* of the hybrid order book for the specific trading pair.\n    *   Broadcast this data to clients subscribed to that pair.\n\n4.  **Data Format:**\n    *   Define a clear WebSocket message format. A suggested format that supports layered display:\n        `{ type: 'HYBRID_ORDER_BOOK_UPDATE', pair: 'SIM_BTC/SIM_USD', data: { bids: [{price, qty, source: 'user'|'binance'}, ...], asks: [{price, qty, source: 'user'|'binance'}, ...] } }`\n    *   The `source` attribute will help the frontend distinguish between user orders and Binance liquidity for the layered display.\n\n5.  **Integration Points:**\n    *   Ensure `MatchingEngine.js` and `OrderBookService.js` correctly trigger updates to the hybrid order book and its subsequent broadcast.\n    *   Leverage Task 18 for the source of Binance data.\n    *   Leverage Task 14 for the WebSocket broadcasting mechanism.\n    *   Leverage Task 16 for user order events.",
      "testStrategy": "1. Verify that frontend clients receive WebSocket messages when the hybrid order book changes for a subscribed pair.\n2. Confirm that updates are triggered by:\n    *   New user orders.\n    *   User order cancellations.\n    *   User order fills (trades).\n    *   Updates from the Binance order book data stream.\n3. The data received by the client must accurately reflect the complete current state of the hybrid order book on the server, clearly distinguishing between user orders and Binance liquidity (e.g., via a 'source' field).\n4. Test scenarios with varying levels of user orders and Binance market depth to ensure correct merging and broadcasting.\n5. Ensure the broadcast data structure supports the intended layered display on the frontend.",
      "subtasks": [
        {
          "id": "19_1",
          "title": "Design hybrid order book data structure and WebSocket message format",
          "status": "pending",
          "description": "Define the in-memory structure for the hybrid order book (combining user and Binance orders) and the precise JSON format for WebSocket messages broadcasting these updates. Ensure the format supports distinguishing order sources for layered display."
        },
        {
          "id": "19_2",
          "title": "Implement hybrid order book merging logic",
          "status": "pending",
          "description": "Develop logic in `OrderBookService.js` or a new module to merge local user orders with incoming Binance order book data to form and maintain the consolidated hybrid order book."
        },
        {
          "id": "19_3",
          "title": "Integrate user order events for hybrid book updates",
          "status": "pending",
          "description": "Modify event handling for user order changes (add, cancel, fill) in `MatchingEngine.js` or `OrderBookService.js` to trigger updates and re-broadcasting of the hybrid order book."
        },
        {
          "id": "19_4",
          "title": "Integrate Binance data feed for hybrid book updates",
          "status": "pending",
          "description": "Connect the Binance data feed (from Task 18) to the hybrid order book module, ensuring that updates from the external market trigger recalculation and re-broadcasting of the hybrid order book."
        },
        {
          "id": "19_5",
          "title": "Implement WebSocket broadcasting of hybrid order book",
          "status": "pending",
          "description": "Implement the mechanism to serialize the complete hybrid order book state and broadcast it via WebSockets to subscribed clients upon any relevant change."
        },
        {
          "id": "19_6",
          "title": "Develop tests for hybrid order book broadcasting",
          "status": "pending",
          "description": "Write unit and integration tests covering hybrid order book construction, update triggers from both user and Binance sources, and WebSocket broadcasting accuracy and data format."
        }
      ]
    },
    {
      "id": 20,
      "title": "FE: Real-time Order Book Visualization",
      "description": "Create a Svelte component to visualize the live order book (bids and asks). This component should subscribe to WebSocket updates for the selected cryptocurrency pair and efficiently re-render the display when new data arrives.",
      "details": "Create `OrderBook.svelte` component. Props: `selectedPair`. On component mount or when `selectedPair` changes: send a WebSocket message to subscribe to that pair's order book updates (if backend requires explicit subscription). Listen for `ORDER_BOOK_UPDATE` messages. When data arrives, update local Svelte stores or component state for bids and asks. Render two lists (bids in green, asks in red), sorted by price, showing price, quantity, and cumulative quantity. Use Svelte's reactivity for efficient DOM updates (`{#each ... key=...}`).",
      "testStrategy": "Order book display updates in near real-time when orders are placed or matched on the backend. Bids and asks are displayed correctly, sorted, and styled. Performance should be acceptable.",
      "priority": "high",
      "dependencies": [
        8,
        15,
        19
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 21,
      "title": "BE: Real-time User Notifications Service",
      "description": "Implement a backend service to send targeted real-time notifications (e.g., order filled, order partially filled, insufficient funds, balance updates) to specific users via WebSockets.",
      "details": "Maintain a mapping of connected WebSocket clients to user IDs (e.g., store `userId` on `ws` object after authentication via socket, or have clients send their JWT for initial socket auth). When an event occurs (e.g., order fill from `TradeExecution`): identify the relevant user(s). Send a targeted WebSocket message. Example: `{ type: 'USER_NOTIFICATION', message: 'Your buy order for 1 SIM_BTC at 10000 SIM_USD was filled.', details: {...} }` or `{ type: 'BALANCE_UPDATE', currency: 'SIM_USD', newBalance: 5000 }`.",
      "testStrategy": "Specific users receive notifications relevant to their actions (e.g., trade confirmations, balance changes). Other users do not receive these notifications. Messages are correctly formatted.",
      "priority": "medium",
      "dependencies": [
        14,
        18
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 22,
      "title": "FE: Display Real-time User Notifications",
      "description": "Develop frontend logic to listen for user-specific WebSocket notifications and display them to the user (e.g., as toast messages or in a notification feed). Dynamically update displayed balances if a balance update notification is received.",
      "details": "In Svelte client, listen for `USER_NOTIFICATION` and `BALANCE_UPDATE` messages. For `USER_NOTIFICATION`, display the message using a toast component (e.g., `svelte-toast`) or add to a list. For `BALANCE_UPDATE`, update the Svelte store holding user balances, which should reactively update the UI (e.g., `AccountDashboard.svelte`).",
      "testStrategy": "User sees notifications for their own trade events. Balances displayed on the dashboard update automatically when a balance notification is received via WebSocket.",
      "priority": "medium",
      "dependencies": [
        10,
        15,
        21
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 23,
      "title": "BE/FE: Stripe Integration for Simulated Fiat Deposits",
      "description": "Integrate Stripe for simulated fiat deposits. Frontend: use Stripe Elements to collect test card details and get a payment token. Backend: API endpoint to receive token, use Stripe Node.js SDK to create a test charge. On success, update user's fiat balance in `Accounts` table and create a `Transaction` record.",
      "details": "FE: Add 'Deposit Fiat' section. Use `@stripe/stripe-js` and `@stripe/react-stripe-js` (or Svelte equivalent for Stripe Elements). Collect amount, use Stripe Elements for card form. On submit, call `stripe.createPaymentMethod()` or `stripe.confirmCardPayment()`. Send paymentMethodId/token and amount to backend. BE: `/payments/stripe-deposit` POST endpoint. Use `stripe` Node.js library (`npm install stripe`). `stripe.paymentIntents.create({ amount, currency: 'usd', payment_method, confirm: true })` with test keys. On success: update user's 'SIM_USD' balance in `Accounts`. Create a `Transactions` record (user_id, type='deposit_fiat', currency_code='SIM_USD', amount, status='completed', external_transaction_id=stripe_charge_id). The `Transactions` table schema needs to be defined (similar to PRD: transaction_id, user_id, type, currency_code_or_crypto_id, amount, status, external_transaction_id, timestamp).",
      "testStrategy": "User can go through Stripe test payment flow. Successful test payment updates user's fiat balance on backend and in UI. A transaction record is created. Stripe dashboard shows test transaction.",
      "priority": "medium",
      "dependencies": [
        4,
        9,
        11
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 24,
      "title": "BE/FE: Crypto Wallet Integration - Simulated Deposits",
      "description": "Implement basic crypto wallet integration for simulated deposits. Frontend: display a unique (or shared for simulation) testnet deposit address for a selected crypto. Backend: mechanism to (manually or via script) monitor this address on a testnet (e.g., Sepolia for ETH, Solana testnet for SOL). On detecting a 'deposit', credit user's `CryptoHolding` balance and create a `Transaction` record.",
      "details": "FE: 'Deposit Crypto' section. User selects crypto (e.g., 'SIM_ETH_Sepolia'). Display a fixed testnet address controlled by the application. BE: For simulation, this might be a manual process initially: admin checks testnet explorer (Etherscan Sepolia) for incoming transactions to the exchange's address. If a deposit is confirmed, admin manually triggers an API endpoint or DB update to credit user's `CryptoHoldings` for the specific crypto and create a `Transactions` record (type='deposit_crypto'). More advanced: script using `ethers.js` or `@solana/web3.js` to periodically query balance/transactions for the exchange's address.",
      "testStrategy": "User is shown a deposit address. After simulating a testnet transfer to this address, their simulated crypto balance is updated on the platform (manually or via script). A transaction record is created.",
      "priority": "low",
      "dependencies": [
        4,
        9,
        11,
        23
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 25,
      "title": "BE/FE: Crypto Wallet Integration - Simulated Withdrawals",
      "description": "Implement basic crypto wallet integration for simulated withdrawals. Frontend: form for withdrawal address and amount. Backend: API to receive request, check balance, simulate transfer (log it, no actual testnet transaction unless time permits), debit user's `CryptoHolding` balance, and create a `Transaction` record.",
      "details": "FE: 'Withdraw Crypto' section. User selects crypto, enters amount and their external testnet wallet address. Submit to backend. BE: `/wallet/initiate-withdrawal` POST endpoint. Validate user has sufficient balance in `CryptoHoldings`. If yes: debit balance. Create `Transactions` record (type='withdrawal_crypto', status='pending' or 'completed' for simulation). For actual testnet transaction (advanced): use `ethers.js` or `@solana/web3.js` with exchange's private key to send funds. For simulation, just log the intent.",
      "testStrategy": "User can request a withdrawal. If sufficient balance, simulated balance is debited. A transaction record is created. If actual testnet tx implemented, verify on explorer.",
      "priority": "low",
      "dependencies": [
        4,
        9,
        11,
        23,
        24
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 26,
      "title": "BE/FE: Trade History Feature",
      "description": "Develop a feature for users to view their trade history. Backend: API endpoint to fetch all trades for the authenticated user from the `Trades` table. Frontend: Display this history in a clear, tabular format.",
      "details": "BE: `/trades/history` GET endpoint, protected by auth. Query `Trades` table for records where `buyer_user_id` or `seller_user_id` matches `req.user.id`. Return list of trades (pair, type (buy/sell from user's perspective), quantity, price, timestamp). FE: `TradeHistory.svelte` component. Fetch data from `/trades/history`. Display in a table.",
      "testStrategy": "User can view their past trades. Data should be accurate and match records in the `Trades` table. Display should clearly indicate if user was buyer or seller for each trade.",
      "priority": "medium",
      "dependencies": [
        4,
        18
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 27,
      "title": "BE/FE: (Optional) Admin Panel Basics",
      "description": "If time permits, implement basic admin functionalities. This could include a simple UI and corresponding backend APIs for an 'admin' role to view all users, manage list of tradable cryptocurrencies (add/edit/disable), or view system-wide trade statistics.",
      "details": "BE: Define 'admin' role in `Users` table. Create admin-only routes protected by authorization middleware (e.g., `/admin/users`, `/admin/cryptocurrencies`). Implement logic for admin actions. FE: Create separate admin section/components, visible only to admin users. Display relevant data and provide forms for admin actions.",
      "testStrategy": "Admin user can log in and access admin panel. Non-admin users cannot. Admin actions (e.g., disabling a cryptocurrency) reflect correctly in the system.",
      "priority": "low",
      "dependencies": [
        4,
        7
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 28,
      "title": "FE: UI/UX Styling & Refinement",
      "description": "Apply consistent styling across the Svelte application. Focus on clarity, simplicity, and usability, especially for the target 'Curious Learner' persona. Ensure basic responsiveness and address the 'attempt at styling' soft requirement. Consider a lightweight CSS framework or custom CSS.",
      "details": "Use global CSS styles or component-scoped styles in Svelte. Choose a color scheme, typography. Ensure consistent layout for forms, tables, navigation. Make interactive elements clear. Test on common desktop screen sizes. Consider using Pico.CSS, OpenProps, or custom CSS for a clean look. Focus on readability of order book and trading forms.",
      "testStrategy": "Application has a consistent and presentable visual appearance. Key user flows are intuitive. No major layout issues on desktop. Meets 'attempt at styling' requirement.",
      "priority": "medium",
      "dependencies": [
        5,
        6,
        8,
        10,
        13,
        20,
        22,
        23,
        24,
        25,
        26
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 29,
      "title": "ALL: GDPR Compliance Implementation",
      "description": "Implement GDPR compliance measures. This includes data minimization in logging and data storage, providing a clear privacy statement/policy page, and outlining (or implementing stubs for) how user data requests (export, deletion) would be handled. This is a 'production ready' hard requirement.",
      "details": "Review all data stored and logged; ensure only necessary data is kept. Create a static `PrivacyPolicy.svelte` page outlining data usage, storage, user rights. For data export/deletion: plan the process. For MVP, this might be a statement that users can contact support, and backend stubs for admin to manually process requests. Ensure user consent for cookies/tracking if any are used beyond essential session management.",
      "testStrategy": "Privacy policy page is accessible. Data handling practices reviewed for minimization. Plan for data subject requests is documented. No unnecessary personal data logged.",
      "priority": "high",
      "dependencies": [
        28
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 30,
      "title": "ALL: Final Testing, Code Cleanup & Documentation",
      "description": "Conduct comprehensive end-to-end testing of all user flows and features. Remove all `console.log` statements, unused code, and unfinished snippets. Ensure code style is consistent. Write or update documentation for key architectural decisions and setup. Prepare for showcasing the application.",
      "details": "Manually test all user flows: registration, login, viewing markets, placing orders, trade execution, balance updates, notifications, deposits/withdrawals, trade history. Fix any bugs. Search codebase for `console.log` and remove. Delete commented-out code blocks and unused files/functions. Run linters/formatters. Document database schema, API endpoints, and any complex logic (e.g., matching engine). Prepare demo script for exam.",
      "testStrategy": "All features work as expected. Codebase is clean and meets 'production ready' requirements. Documentation is sufficient for understanding the project. Application is ready for demonstration.",
      "priority": "high",
      "dependencies": [
        29
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 31,
      "title": "BE: OpenAPI Specification Compliance",
      "description": "Refactor all API endpoints to comply with OpenAPI specifications",
      "details": "Create OpenAPI specification document and ensure all endpoints follow standards for request/response formats, status codes, error responses, and data schemas. Add validation middleware and documentation generation.",
      "testStrategy": "",
      "status": "done",
      "dependencies": [
        1,
        2,
        3,
        4,
        "33"
      ],
      "priority": "high",
      "subtasks": []
    },
    {
      "id": 32,
      "title": "BE: Error Handling Architecture Refactor",
      "description": "Remove all error handling from services and repositories, centralizing it in routers",
      "details": "Refactor the backend architecture to move all try-catch blocks and error handling logic from service and repository layers to their respective routers. Services and repositories should throw errors and let routers handle HTTP responses and status codes.",
      "testStrategy": "",
      "status": "done",
      "dependencies": [
        1,
        2,
        3,
        4
      ],
      "priority": "high",
      "subtasks": [
        {
          "id": 1,
          "title": "Audit Current Error Handling in Services and Repositories",
          "description": "Review all existing service and repository files to identify current error handling patterns and try-catch blocks that need to be moved to routers",
          "details": "",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 32
        },
        {
          "id": 2,
          "title": "Refactor User Services to Remove Error Handling",
          "description": "Remove try-catch blocks from user services and let them throw errors instead",
          "details": "",
          "status": "done",
          "dependencies": [
            1
          ],
          "parentTaskId": 32
        },
        {
          "id": 3,
          "title": "Refactor Other Services (Crypto, Account, Order) to Remove Error Handling",
          "description": "Remove try-catch blocks from cryptocurrency, account, and order services",
          "details": "",
          "status": "done",
          "dependencies": [
            1
          ],
          "parentTaskId": 32
        },
        {
          "id": 4,
          "title": "Update All Routers with Centralized Error Handling",
          "description": "Add proper try-catch blocks and error handling to all router files to handle errors thrown by services",
          "details": "",
          "status": "done",
          "dependencies": [
            2,
            3
          ],
          "parentTaskId": 32
        },
        {
          "id": 5,
          "title": "Test and Verify Error Handling Refactor",
          "description": "Test all endpoints to ensure error handling works correctly and consistently across all routers",
          "details": "<info added on 2025-06-01T14:09:48.577Z>\nSuccessfully identified and fixed authentication middleware OpenAPI compliance issue. Authentication error handling now works correctly:\n\nFixed authentication middleware to use sendUnauthorized helper.\nVerified accounts endpoint returns proper 401 with error object.\nVerified orders endpoint returns proper 401 with error object.\nRemoved hardcoded authentication bypass (completed Task 35).\n\nThe error handling refactor is working correctly. All routers have comprehensive try-catch blocks and proper error response formatting.\n</info added on 2025-06-01T14:09:48.577Z>\n<info added on 2025-06-01T14:11:53.726Z>\nCompleted comprehensive error handling verification across all routers:\n\nAuthentication Errors: 401 responses with proper error format\nValidation Errors: 400/422 responses for OpenAPI and custom validation\nBusiness Logic Errors: 409 for conflicts, 422 for custom business rules\nResource Not Found: 404 responses with proper error messages\nInput Validation: 400 responses for malformed parameters\nAuthenticated Endpoints: Proper success responses with valid sessions\nAuthenticated Error Handling: 404 errors work correctly in authenticated context\n\nAll routers consistently use proper error response format:\n{\n  \"error\": \"ErrorType\",\n  \"message\": \"Descriptive error message\"\n}\n\nStatus codes are appropriate:\n- 400: Bad Request (OpenAPI validation)\n- 401: Unauthorized (authentication required)\n- 404: Not Found (resource doesn't exist)\n- 409: Conflict (duplicate resources)\n- 422: Unprocessable Entity (business rule violations)\n\nError handling refactor is complete and working perfectly.\n</info added on 2025-06-01T14:11:53.726Z>",
          "status": "done",
          "dependencies": [
            4
          ],
          "parentTaskId": 32
        }
      ]
    },
    {
      "id": 33,
      "title": "BE: Validation Schemas Implementation",
      "description": "Create comprehensive validation schemas for all existing features using a validation library",
      "details": "Implement validation schemas for all existing backend features including users, auth, cryptocurrencies, accounts, and orders. Choose and integrate a validation library (e.g., Joi, Yup, or Zod) and create reusable validation schemas for request bodies, query parameters, and response data. This includes validation for registration, login, cryptocurrency data, account balances, and order placement.",
      "testStrategy": "",
      "status": "done",
      "dependencies": [
        1,
        2,
        3,
        4
      ],
      "priority": "high",
      "subtasks": []
    },
    {
      "id": 34,
      "title": "BE: API Key Authentication System",
      "description": "Implement API key generation and authentication system for API access",
      "details": "Create a system for generating, managing, and authenticating API keys for external access to the trading platform APIs. This includes API key generation endpoints, storage in database, middleware for API key validation, and rate limiting per API key. This is a non-urgent enhancement for future API access management.",
      "testStrategy": "",
      "status": "pending",
      "dependencies": [
        4,
        31,
        32,
        33
      ],
      "priority": "low",
      "subtasks": []
    },
    {
      "id": 35,
      "title": "BE: Fix Authentication Middleware Security Bypass",
      "description": "Remove hardcoded authentication bypass from backend/shared/middleware/authorisation.js. The middleware currently hardcodes userId=1 and role='admin' for all requests instead of validating sessions. This creates a critical security vulnerability.",
      "details": "1. Remove the hardcoded authentication bypass (lines 9-14 in authorisation.js)\n2. Uncomment and restore the proper session validation logic (lines 2-8)\n3. Ensure proper 401 responses for unauthenticated requests\n4. Verify req.user is correctly populated from session data\n5. Test all protected endpoints to ensure authentication works correctly\n\nThis is critical for application security before any production deployment.",
      "testStrategy": "1. Test that protected routes return 401 when no session cookie is sent\n2. Test that protected routes return 401 when session exists but userId is missing\n3. Test that protected routes allow access when valid session exists\n4. Verify req.user is correctly populated with session data\n5. Test logout functionality properly destroys sessions",
      "status": "done",
      "dependencies": [
        32,
        33
      ],
      "priority": "high",
      "subtasks": []
    },
    {
      "id": 36,
      "title": "BE: Restore OpenAPI Cookie Authentication Validation",
      "description": "Ensure the OpenAPI specification properly validates cookie authentication and that the cookieAuth security scheme is correctly configured for all protected endpoints.",
      "details": "1. Verify the cookieAuth security scheme is properly defined in openapi.yml components/securitySchemes\n2. Ensure all protected endpoints have the 'security: - cookieAuth: []' declaration\n3. Confirm the OpenAPI validation middleware correctly validates cookies before requests reach application middleware\n4. Test that OpenAPI validation rejects requests without proper cookies\n5. Ensure API documentation accurately reflects authentication requirements\n\nThis provides the first line of defense and ensures API documentation accuracy.",
      "testStrategy": "1. Test that OpenAPI validation rejects requests without connect.sid cookie\n2. Test that OpenAPI validation rejects requests with invalid session IDs\n3. Verify protected endpoints in API docs show authentication requirement\n4. Test that valid authenticated requests pass OpenAPI validation\n5. Confirm error responses match OpenAPI specification",
      "status": "deferred",
      "dependencies": [
        31,
        35
      ],
      "priority": "high",
      "subtasks": []
    },
    {
      "id": 37,
      "title": "Test AI Functionality with Google API Key",
      "description": "Perform comprehensive testing to verify that the Task Master AI features, integrated with the newly added Google API key, are operating correctly and delivering accurate results.",
      "details": "This task involves end-to-end testing of all AI-powered functionalities within the Task Master application.\nKey objectives include:\n1.  Confirmation that the Google API key is correctly configured and utilized by the AI modules.\n2.  Identification and systematic testing of each specific AI feature (e.g., AI-assisted task description generation, dependency suggestion, content summarization, etc.).\n3.  Validation of AI feature inputs, processing logic (at a high level), and output accuracy and relevance.\n4.  Ensuring backend services/APIs supporting these AI features are stable and responsive.\n5.  Verifying robust error handling for scenarios such as Google API errors (e.g., quota limits, invalid key, network connectivity issues) or invalid inputs to AI features.",
      "testStrategy": "1. **Environment & Configuration Verification**:\n    *   Confirm the Google API key is securely configured and accessible in the testing environment.\n    *   Ensure all AI-related modules/services are deployed and running.\n2.  **AI Feature Inventory & Test Case Design**:\n    *   Compile an exhaustive list of all implemented Task Master AI features.\n    *   For each feature, design specific test cases covering:\n        *   **Positive Scenarios**: Valid inputs expected to yield successful AI processing and relevant outputs.\n        *   **Edge Cases**: Inputs that test the boundaries of expected behavior.\n        *   **Negative Scenarios (Input Validation)**: Invalid or malformed inputs to ensure graceful error handling by the system before AI invocation (if applicable).\n3.  **Functional Testing (Per AI Feature)**:\n    *   Execute positive test cases: Provide valid inputs and meticulously verify the AI-generated output for accuracy, relevance, and correct formatting.\n    *   Execute edge case test cases: Observe system behavior and AI output.\n    *   Execute negative input test cases: Confirm user-friendly error messages and system stability.\n4.  **Google API Interaction & Error Handling Tests**:\n    *   Simulate Google API unavailability or errors (if feasible in a controlled test environment, e.g., by temporarily revoking/misconfiguring the key or using mock services that simulate error responses).\n    *   Verify that the Task Master application handles these external errors gracefully (e.g., informative messages to the user, proper logging, no crashes).\n    *   Test with a valid key that might hit a (test) quota limit if possible, to see how that's handled.\n5.  **Output Validation**:\n    *   For features generating text or suggestions, assess the quality, coherence, and usefulness of the AI output against predefined criteria or expert judgment.\n    *   For features making predictions or classifications, compare results against known outcomes if possible.\n6.  **Logging & Monitoring Review**:\n    *   Inspect application logs during testing for any errors, warnings, or unexpected behavior related to AI feature execution or Google API calls.\n    *   Verify that successful operations and significant errors are logged appropriately for diagnostics.\n7.  **Basic Performance Check**:\n    *   For interactive AI features, assess if the response time is acceptable from a user experience perspective. This is an observational check, not a formal load test.",
      "status": "pending",
      "dependencies": [
        35,
        36
      ],
      "priority": "low",
      "subtasks": []
    },
    {
      "id": 38,
      "title": "Simple MCP AI Functionality Verification",
      "description": "Perform a targeted, simple test to confirm a core capability of the MCP AI (Task Master AI) is functioning as expected, post-integration with the Google API key and initial comprehensive testing.",
      "details": "1. Prerequisite: MCP AI (Task Master AI) has been integrated with the Google API key and has undergone comprehensive testing (as per Task 37).\n2. Identify a single, straightforward AI function to test. Example: Given a short user story, the AI should generate 3 relevant tags.\n3. Input: A specific, concise user story (e.g., \"As a user, I want to reset my password so I can regain access to my account.\").\n4. Expected Output: A list of 3 relevant tags (e.g., [\"password reset\", \"account recovery\", \"security\"]). The expected tags should be predefined for the chosen test case.\n5. Execution:\n    a. Access the MCP AI interface or API endpoint.\n    b. Provide the defined input user story.\n    c. Capture the AI's generated tags.",
      "testStrategy": "1. Verify the MCP AI endpoint is accessible and responsive.\n2. Submit the predefined user story to the AI.\n3. Collect the generated tags from the AI's response.\n4. Compare the generated tags against the predefined expected tags. The test passes if the generated output sufficiently matches the expected output (e.g., at least 2 out of 3 tags match or are clear semantic equivalents, or as defined by the specific test case criteria).\n5. Document the input, expected output, actual output, and pass/fail result. Note any discrepancies or unexpected behavior for further review.",
      "status": "done",
      "dependencies": [
        37
      ],
      "priority": "low",
      "subtasks": []
    },
    {
      "id": 39,
      "title": "BE: Implement Google OAuth 2.0 Login Integration",
      "description": "Integrate Google OAuth 2.0 to allow users to sign in or register using their Google accounts. This involves backend setup for the OAuth flow, handling Google's callback, and managing user account creation/linking and session state.",
      "details": "### 1. Google Cloud Project Setup:\n   - Navigate to the Google Cloud Console.\n   - Create a new project or select an existing one.\n   - Enable the \"Google People API\" under \"APIs & Services -> Enabled APIs & Services\".\n   - Configure the OAuth consent screen under \"APIs & Services -> OAuth consent screen\":\n     - Specify User Type (e.g., External).\n     - Provide App name, User support email, App logo (optional).\n     - Add Scopes: `openid`, `https://www.googleapis.com/auth/userinfo.email`, `https://www.googleapis.com/auth/userinfo.profile`.\n     - Fill in developer contact information.\n   - Create OAuth 2.0 Client ID under \"APIs & Services -> Credentials\":\n     - Select Application type: \"Web application\".\n     - Name it (e.g., \"Exchange App Web Client\").\n     - Add Authorized JavaScript origins (e.g., frontend URL like `http://localhost:3001`).\n     - Add Authorized redirect URIs for the backend (e.g., `http://localhost:3000/api/auth/google/callback`).\n     - Securely store the generated Client ID and Client Secret (e.g., in environment variables).\n\n### 2. Backend Implementation (using Passport.js):\n   - Install necessary packages: `npm install passport passport-google-oauth20 express-session`.\n   - Ensure `express-session` middleware is configured and initialized before Passport middleware. This might be partially covered by Task 4 but ensure it's compatible with Passport's session needs.\n   - Initialize Passport middleware: `app.use(passport.initialize()); app.use(passport.session());`.\n   - Configure `passport-google-oauth20` strategy:\n     ```javascript\n     passport.use(new GoogleStrategy({\n       clientID: process.env.GOOGLE_CLIENT_ID,\n       clientSecret: process.env.GOOGLE_CLIENT_SECRET,\n       callbackURL: '/api/auth/google/callback',\n       scope: ['profile', 'email']\n     },\n     async (accessToken, refreshToken, profile, done) => {\n       try {\n         const googleId = profile.id;\n         const email = profile.emails && profile.emails[0] ? profile.emails[0].value : null;\n         const firstName = profile.name ? profile.name.givenName : '';\n         const lastName = profile.name ? profile.name.familyName : '';\n\n         if (!email) {\n           return done(new Error('Email not provided by Google.'), null);\n         }\n\n         let user = await User.findOne({ where: { googleId: googleId } });\n         if (user) {\n           return done(null, user);\n         }\n\n         user = await User.findOne({ where: { email: email } });\n         if (user) {\n           // Link Google ID to existing email account\n           user.googleId = googleId;\n           // Optionally update name fields if they are empty or prefer Google's\n           user.firstName = user.firstName || firstName;\n           user.lastName = user.lastName || lastName;\n           user.isEmailVerified = true; // Google verifies email\n           await user.save();\n           return done(null, user);\n         }\n\n         // Create new user\n         const newUser = await User.create({\n           googleId: googleId,\n           email: email,\n           firstName: firstName,\n           lastName: lastName,\n           isEmailVerified: true, // Email from Google is considered verified\n           // Password field can be null or a placeholder if schema requires it for OAuth users\n           // Ensure User model (from Task 3) accommodates this\n         });\n         return done(null, newUser);\n       } catch (err) {\n         return done(err, null);\n       }\n     }));\n     ```\n   - Implement Passport `serializeUser` and `deserializeUser` for session management:\n     ```javascript\n     passport.serializeUser((user, done) => {\n       done(null, user.id); // Assuming user object has an 'id' property (PK)\n     });\n\n     passport.deserializeUser(async (id, done) => {\n       try {\n         const user = await User.findByPk(id);\n         done(null, user);\n       } catch (err) {\n         done(err);\n       }\n     });\n     ```\n   - Update User model/schema (from Task 2/3) to include `googleId` (String, unique, nullable), `firstName`, `lastName`, and `isEmailVerified` (Boolean) fields if not already present.\n\n### 3. API Routes:\n   - **`GET /api/auth/google`**: Initiates the Google OAuth flow.\n     ```javascript\n     router.get('/auth/google', passport.authenticate('google'));\n     ```\n   - **`GET /api/auth/google/callback`**: Handles the callback from Google.\n     ```javascript\n     router.get('/auth/google/callback',\n       passport.authenticate('google', {\n         successRedirect: process.env.GOOGLE_OAUTH_SUCCESS_REDIRECT_URL || '/dashboard',\n         failureRedirect: process.env.GOOGLE_OAUTH_FAILURE_REDIRECT_URL || '/login?error=google_auth_failed',\n         failureMessage: true // Store failure message in req.session.messages\n       })\n     );\n     ```\n   - Ensure these routes adhere to OpenAPI specifications (Task 31) and centralized error handling (Task 32).\n\n### 4. Session Management:\n   - Successful authentication via Passport will establish a session using `express-session` and populate `req.user`.\n   - This session should be compatible with the authentication middleware from Task 4.",
      "testStrategy": "### 1. Unit Tests (e.g., Jest, Mocha):\n   - Test the Passport strategy's verify callback logic extensively:\n     - Mock `User.findOne`, `User.create`, `user.save`.\n     - Scenario: User found by `googleId`.\n     - Scenario: User found by `email` (account linking), verify `googleId` and `isEmailVerified` are updated.\n     - Scenario: New user creation, verify all fields are set correctly.\n     - Scenario: Google profile does not provide an email.\n     - Scenario: Database errors during find or save operations.\n   - Test `serializeUser` and `deserializeUser` with mock user objects and IDs.\n\n### 2. Integration Tests (e.g., Supertest):\n   - Test `GET /api/auth/google` endpoint:\n     - Verify it returns a 302 redirect.\n     - Verify the `Location` header in the response points to Google's OAuth URL with correct parameters (client_id, redirect_uri, scope, response_type).\n   - Test `GET /api/auth/google/callback` (requires mocking Google's response or a more complex setup):\n     - Simulate a successful callback from Google: Mock `passport.authenticate` or the strategy execution to return a mock user.\n       - Verify session cookie is set.\n       - Verify redirection to `successRedirect` URL.\n     - Simulate a failed callback from Google:\n       - Verify redirection to `failureRedirect` URL.\n       - Verify appropriate error message is available (e.g., in session or query param).\n\n### 3. Manual End-to-End Testing:\n   - **Prerequisites**: Frontend with a \"Sign in with Google\" button pointing to `/api/auth/google`.\n   - **Scenario 1: New User Registration**\n     - Use a Google account not previously registered in the application.\n     - Click \"Sign in with Google\", authenticate with Google, grant permissions.\n     - Verify successful redirection to the application's dashboard or specified success URL.\n     - Check database: A new user record should exist with `googleId`, email, name from Google, and `isEmailVerified` set to true.\n     - Verify session is active and user can access protected routes.\n   - **Scenario 2: Existing Google User Login**\n     - Log out. Use the same Google account from Scenario 1.\n     - Click \"Sign in with Google\".\n     - Verify successful login and redirection without creating a new user account.\n   - **Scenario 3: Linking Google to Existing Email Account**\n     - Create an account using traditional email/password (e.g., `test.user@example.com`).\n     - Log out. Click \"Sign in with Google\" using a Google account associated with `test.user@example.com`.\n     - Verify successful login. Check database: The existing user record for `test.user@example.com` should now have its `googleId` field populated and `isEmailVerified` set to true.\n   - **Scenario 4: Google Authentication Failure**\n     - On Google's consent screen, deny permission or simulate an error from Google's side.\n     - Verify redirection to the specified `failureRedirect` URL with an appropriate error indicator.\n   - **Scenario 5: Session Persistence**\n     - After logging in with Google, close and reopen the browser (if session is persistent) or navigate within the app.\n     - Verify the user remains logged in and the session is correctly managed by the middleware from Task 4.\n\n### 4. Security Checks:\n   - Verify Client ID and Client Secret are stored securely as environment variables and not exposed client-side.\n   - Ensure the `redirect_uri` configured in Google Cloud Console exactly matches the one used by the backend to prevent open redirector vulnerabilities.",
      "status": "pending",
      "dependencies": [
        3,
        4,
        31,
        32,
        33
      ],
      "priority": "medium",
      "subtasks": []
    },
    {
      "id": 40,
      "title": "Refactor Validation to Express.js Middleware with Valibot",
      "description": "Refactor existing validation logic from service layers to a centralized Express.js middleware pattern using Valibot schemas. This will improve separation of concerns and standardize error handling for request validation.",
      "details": "This task involves creating reusable Express.js middleware for request validation using the Valibot schemas developed in Task 33. Key steps include:\n1. Develop a generic validation middleware factory function. This function should accept a Valibot schema as an argument.\n2. The middleware should parse and validate `req.body`, `req.params`, and `req.query` against the provided schema.\n3. Upon successful validation, the middleware should call `next()` to pass control to the next handler. If Valibot parsing results in transformed/parsed data, it should be attached to `req` (e.g., `req.validatedData = parsedOutput`).\n4. If validation fails, the middleware must not call `next()`. Instead, it should immediately respond with a 400 Bad Request status and a JSON body detailing the validation errors, utilizing Valibot's error reporting capabilities for clear messages.\n5. Identify all routes currently performing validation within their service/controller logic.\n6. Integrate the new validation middleware into these Express routes, applying the appropriate Valibot schema for each.\n   Example: `router.post('/resource', validationMiddleware(resourceCreateSchema), resourceController.createResource);`\n7. Remove all data validation logic from the service layer methods. Services should now assume that incoming data has been pre-validated and is schema-compliant.\n8. Ensure that this refactoring centralizes validation error handling, providing consistent error responses across the API for input validation issues.",
      "testStrategy": "Verify the correct implementation through a combination of unit and integration tests:\n1. **Unit Tests for Validation Middleware**:\n   - Create test suites for the generic validation middleware factory.\n   - Test with various Valibot schemas (covering `body`, `params`, `query`).\n   - Mock `req`, `res`, `next` objects.\n   - Assert that `next()` is called when provided with valid data matching the schema.\n   - Assert that `res.status(400).json()` is called with a correctly structured error payload (derived from Valibot errors) when provided with invalid data, and `next()` is not called.\n   - Verify that parsed and validated data is correctly attached to the `req` object if applicable.\n2. **Integration Tests for Routes**:\n   - For each API endpoint refactored to use the new validation middleware:\n     - Send requests with valid payloads: Confirm the request passes validation, reaches the controller/service, and returns the expected successful response (e.g., 200 OK, 201 Created).\n     - Send requests with various invalid payloads (e.g., missing required fields, incorrect data types, values violating schema constraints): Confirm a 400 Bad Request response is returned with a JSON body detailing the specific validation errors. Ensure the underlying service logic is not executed.\n3. **Service Layer Tests Verification**:\n   - Review and update existing service layer tests to ensure they no longer test for input validation that is now handled by the middleware. Service tests should focus on business logic, assuming valid inputs.\n4. **Manual API Testing**:\n   - Use an API client (e.g., Postman) to manually test a selection of refactored endpoints with diverse valid and invalid inputs to confirm behavior and consistent error responses.",
      "status": "deferred",
      "dependencies": [
        33
      ],
      "priority": "medium",
      "subtasks": []
    },
    {
      "id": 41,
      "title": "BE: Refactor OrderService for Improved Maintainability and Testability",
      "description": "Refactor `save()` and `updateByUserAndOrderId()` methods in `OrderService.js` to eliminate code duplication, simplify complex logic using patterns like Strategy, and improve error handling and validation. This will enhance code maintainability, testability, and robustness of the core order processing functionality.",
      "details": "The refactoring of `OrderService.js` methods `save()` and `updateByUserAndOrderId()` will involve the following key activities:\n1.  **Balance Validation Logic Extraction:**\n    *   Identify and consolidate the balance validation logic currently duplicated in `save()` and `updateByUserAndOrderId()`.\n    *   Create a private method, e.g., `_validateAndReserveBalance(userId, orderDetails, existingOrder = null)`, responsible for verifying sufficient funds for both new orders and updates that might affect cost. This method should handle both fiat and crypto balances and consider existing reserved amounts if an order is being updated.\n    *   Refactor `save()` and `updateByUserAndOrderId()` to call this unified balance validation method.\n2.  **Dedicated Buy/Sell Order Processing Handlers:**\n    *   Create distinct private helper methods for buy and sell order logic, e.g., `_processNewBuyOrder(orderData, user)` and `_processNewSellOrder(orderData, user)` for the `save()` method.\n    *   Similarly, create `_processBuyOrderUpdate(orderData, existingOrder, user)` and `_processSellOrderUpdate(orderData, existingOrder, user)` for `updateByUserAndOrderId()` if update logic significantly differs based on order side.\n    *   These handlers will manage specifics like debiting/crediting the correct accounts, unique validation rules, and calculating costs/proceeds for buy vs. sell orders.\n3.  **Strategy Pattern for Order Type/Variant Processing:**\n    *   Define an `IOrderTypeStrategy` interface with methods like `validateOrderTypeSpecifics(orderData, existingOrder = null)`, `calculateCostAndFees(orderData)`, and `prepareOrderAttributes(orderData)`.\n    *   Implement concrete classes such as `LimitOrderStrategy` and `MarketOrderStrategy`.\n    *   `OrderService` methods (`save` and `updateByUserAndOrderId`) will use a context or factory to select and delegate to the appropriate strategy based on `orderData.order_type`. This will replace complex nested conditional structures for order type and variant checking.\n4.  **Consolidate Common Logic & Reduce Duplication:**\n    *   Review `save()` and `updateByUserAndOrderId()` for any remaining duplicated code beyond balance validation and type-specific processing (e.g., common database interaction patterns for creating/updating order records, status transitions, audit logging).\n    *   Extract these into well-named private helper methods to ensure DRY principles are followed throughout the service.\n5.  **Improved Error Handling and Validation Flow:**\n    *   Standardize error responses using specific, custom error classes (e.g., `InsufficientBalanceError`, `InvalidOrderParametersError`, `OrderUpdateNotAllowedError`).\n    *   Refine the validation sequence to be clear, efficient, and fail-fast. Ensure comprehensive validation of all input parameters and business rules.\n    *   Ensure all database operations within `save()` and `updateByUserAndOrderId()` are wrapped in transactions to maintain data integrity.\n6.  **Refactor `updateByUserAndOrderId()` Method:**\n    *   Specifically address the `updateByUserAndOrderId()` method to ensure it fully leverages the new extracted logic (balance validation, strategy pattern for any type-specific update rules, buy/sell handlers if applicable).\n    *   Clearly define which order attributes are updatable by users and enforce these limitations. Validate order status to prevent updates to non-updatable orders (e.g., filled, cancelled).\n    *   Ensure that updates correctly interact with the order's lifecycle and status transitions, and re-validate balances if necessary (e.g., if quantity is increased).",
      "testStrategy": "Verification of the refactored `OrderService.js` will be achieved through comprehensive unit testing:\n1.  **Unit Tests for Extracted Private Methods:**\n    *   For `_validateAndReserveBalance`: Test with sufficient/insufficient fiat/crypto balances for new orders and updates, various user scenarios, and correct handling of existing reservations.\n    *   For `_processNewBuyOrder`/`_processNewSellOrder` (and update counterparts): Test correct processing flow, data transformation, and interaction with mocked dependencies for buy/sell specific logic.\n2.  **Unit Tests for Strategy Pattern Components:**\n    *   For each `IOrderTypeStrategy` implementation (e.g., `LimitOrderStrategy`, `MarketOrderStrategy`):\n        *   Test `validateOrderTypeSpecifics()` with valid and invalid order data specific to that type (e.g., presence/absence of price for limit/market).\n        *   Test `calculateCostAndFees()` for accurate calculations under various conditions.\n        *   Test `prepareOrderAttributes()` for correct construction of order attributes specific to the type.\n3.  **Unit Tests for `save()` Method (Orchestration Logic):**\n    *   Mock all dependencies (database repository, strategy processors, private helper methods).\n    *   Verify that `save()` correctly orchestrates calls to these components for various scenarios: successful limit buy/sell, successful market buy/sell, failures due to balance validation, failures due to order type specific validation, and correct error propagation.\n4.  **Unit Tests for `updateByUserAndOrderId()` Method (Orchestration Logic):**\n    *   Mock all dependencies.\n    *   Verify correct orchestration for scenarios: successful updates (e.g., quantity/price changes if allowed), attempts to update non-existent orders, unauthorized updates (if service layer checks exist), updates to orders in non-updatable states, updates failing due to re-validation (e.g., balance check for increased quantity), and correct error propagation.\n5.  **Error Handling Tests:**\n    *   Ensure that custom error classes are thrown correctly by the service under appropriate failure conditions (e.g., `InsufficientBalanceError`, `InvalidOrderParametersError`).\n    *   Verify that database transaction rollbacks are correctly handled/simulated in tests upon service method failure.\n6.  **Test Coverage:**\n    *   Utilize a code coverage tool (e.g., Jest's built-in coverage) to ensure a high percentage (target >90%) of the refactored code in `OrderService.js` is covered by unit tests, especially critical paths and decision points.\n7.  **Regression Testing:**\n    *   Ensure all existing unit tests related to `OrderService` (if any) continue to pass after refactoring.\n    *   If available, run relevant integration tests that involve order creation and updates to catch any unintended side effects not covered by unit tests.",
      "status": "pending",
      "dependencies": [
        12,
        18
      ],
      "priority": "medium",
      "subtasks": []
    }
  ]
}