{
  "tasks": [
    {
      "id": 1,
      "title": "BE: Project Setup & Basic Express Server",
      "description": "Initialize the Node.js backend project with Express.js. Set up project structure, linting (e.g., ESLint), formatting (e.g., Prettier), and a basic Express server that listens on a port. This forms the absolute foundation for all backend development.",
      "details": "Initialize a new Node.js project (`npm init -y`). Install Express (`npm install express`). Create a main server file (e.g., `server.js` or `app.js`) to set up a basic Express app: `const express = require('express'); const app = express(); const PORT = process.env.PORT || 3000; app.get('/', (req, res) => res.send('Exchange Backend Running')); app.listen(PORT, () => console.log(`Server running on port ${PORT}`));`. Set up scripts in `package.json` for starting the server (e.g., `dev` script using `nodemon`). Configure ESLint and Prettier for code consistency.",
      "testStrategy": "Verify that the Node.js project is initialized, Express is installed, and the basic server starts without errors, responding to a GET request at the root path. Linting and formatting tools should be configurable.",
      "priority": "high",
      "dependencies": [],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 2,
      "title": "BE: Database Selection & Initial Schema Design (Users, Cryptocurrencies, Balances)",
      "description": "Research and finalize the choice of database (leaning PostgreSQL as per PRD). Design the initial database schema for core entities: Users, Cryptocurrencies, Accounts (for fiat balances), and CryptoHoldings (for crypto balances). Implement migration scripts to create these tables.",
      "details": "Confirm PostgreSQL as the database. Install PostgreSQL locally or set up a cloud instance. Install the `pg` Node.js driver (`npm install pg`). Design schema: `Users` (user_id, email, password_hash, role, created_at, updated_at), `Cryptocurrencies` (cryptocurrency_id, symbol, name, description, is_active), `Accounts` (account_id, user_id FK, currency_code (e.g., 'SIM_USD'), balance DECIMAL, created_at, updated_at), `CryptoHoldings` (holding_id, user_id FK, cryptocurrency_id FK, balance DECIMAL, created_at, updated_at). Write SQL scripts or use a migration tool (e.g., `node-pg-migrate`) to create these tables.",
      "testStrategy": "Verify database connection from the Node.js application. Confirm that all specified tables and columns are created correctly in PostgreSQL with appropriate data types and constraints (primary keys, foreign keys, unique constraints).",
      "priority": "high",
      "dependencies": [
        1
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 3,
      "title": "BE: User Authentication Endpoints (Registration, Login)",
      "description": "Implement backend logic for user registration and login. This includes creating a User model, handling password hashing (e.g., using bcryptjs or argon2), storing user data, verifying credentials, and generating session tokens (JWT) or setting up cookie-based sessions.",
      "details": "Create `/auth/register` and `/auth/login` Express routes. For registration: validate input (email, password), hash password using `bcryptjs` (`npm install bcryptjs`), store user in `Users` table. For login: find user by email, compare hashed password, if valid, generate a JWT (`npm install jsonwebtoken`) containing user_id and role. Return token to client. Define User model functions for DB interactions (e.g., `createUser`, `findUserByEmail`).",
      "testStrategy": "Test registration endpoint: new user created in DB, password hashed. Test login endpoint: valid credentials return a token/session, invalid credentials return an error. Check token content.",
      "priority": "high",
      "dependencies": [
        2
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 4,
      "title": "BE: Authentication & Authorization Middleware",
      "description": "Implement middleware for session-based authentication to protect routes that require a logged-in user. The primary focus for this task is on implementing robust authentication middleware. Role-based authorization (e.g., admin/user distinctions) is deferred for now. Ownership-based access control, where necessary, will be handled within specific route handlers rather than a generic authorization middleware.",
      "status": "done",
      "dependencies": [
        3
      ],
      "priority": "high",
      "details": "Create an `authMiddleware` function. This function should:\n1. Check for an active session (e.g., by inspecting `req.session` and verifying the presence of `req.session.userId`).\n2. If a valid session exists (e.g., `req.session.userId` is present), ensure user information (e.g., user ID from `req.session.userId`, role from `req.session.role`) is readily accessible for subsequent handlers. This can be achieved by populating `req.user` (e.g., `req.user = { id: req.session.userId, role: req.session.role }`) or by ensuring route handlers can directly and reliably use `req.session` for this information.\n3. If authentication fails (no active session, or session data is invalid/missing required fields like `userId`), the middleware should send an appropriate error response (e.g., 401 Unauthorized).\n4. Apply this `authMiddleware` to all routes that require a user to be logged in.\nNote: General role-based authorization middleware (e.g., checking for 'admin' vs 'user' roles) is deferred. Specific access control logic, such as ownership checks, will be implemented directly within the relevant route handlers after authentication, using the user information made available by this session-based middleware.",
      "testStrategy": "1. Test that protected routes return a 401 Unauthorized status code when no active session is present (e.g., no session cookie sent, or session store does not recognize the session ID).\n2. Test that protected routes return a 401 Unauthorized status code when a session exists but is invalid or lacks essential user identifiers (e.g., `req.session.userId` is missing).\n3. Test that protected routes allow access (e.g., return a 2xx status code or proceed to the next handler) when a valid session with required user information (e.g., `req.session.userId`) is present.\n4. Verify that user information (e.g., `req.user` if populated, or directly via `req.session`) is correctly populated and accessible with user details (ID, role) after successful session validation.\n(Role-based authorization tests are deferred for this task).",
      "subtasks": []
    },
    {
      "id": 5,
      "title": "FE: Svelte Project Setup & Basic UI Shell",
      "description": "Set up the Svelte frontend project (or SvelteKit if preferred). Create a basic application shell with main layout components (e.g., navbar, footer, main content area) and set up client-side routing if using SvelteKit or a separate router.",
      "details": "Initialize a Svelte project: `npx degit sveltejs/template my-svelte-project` or `npm create svelte@latest my-sveltekit-project`. Set up basic folder structure (components, routes/pages, stores). Create `Navbar.svelte`, `Footer.svelte`, and an `App.svelte` or `+layout.svelte` to structure the main UI. If not using SvelteKit, install a router like `svelte-routing`.",
      "testStrategy": "Verify the Svelte application runs locally. Basic layout components should render. Navigation (if set up) should switch between placeholder pages.",
      "priority": "high",
      "dependencies": [],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 6,
      "title": "FE: User Authentication UI & Logic",
      "description": "Develop Svelte components for user registration and login forms. Implement logic to capture user input, perform client-side validation, and use the `fetch` API to send credentials to the backend authentication endpoints. Manage client-side user session (e.g., store JWT in localStorage, update UI based on auth state).",
      "details": "Create `Register.svelte` and `Login.svelte` components with input fields and submit buttons. Use Svelte stores (e.g., `writable`) for managing user authentication state (token, user info). On form submission, use `fetch` to POST to `/auth/register` or `/auth/login`. Handle responses: store token in localStorage on success, display errors on failure. Implement logout functionality (clear token, reset auth state). Conditionally render UI elements based on auth state (e.g., show Login/Register or Logout/Profile links).",
      "testStrategy": "User can register via the form, data sent to backend. User can log in, token received and stored. UI updates based on login status. Logout clears session. Error messages displayed for invalid input/credentials.",
      "priority": "high",
      "dependencies": [
        3,
        5
      ],
      "status": "done",
      "subtasks": [
        {
          "id": 1,
          "title": "Create Register.svelte Component",
          "description": "Develop the `Register.svelte` component, including form inputs for user registration (e.g., email, password, confirm password) and implement client-side validation logic for these inputs.",
          "dependencies": [],
          "details": "Form fields: username (optional), email, password, confirm password. Client-side validation: required fields, email format, password strength, password confirmation match. Display appropriate error messages.",
          "status": "done"
        },
        {
          "id": 2,
          "title": "Create Login.svelte Component",
          "description": "Develop the `Login.svelte` component, including form inputs for user login (e.g., email, password) and implement client-side validation logic.",
          "dependencies": [],
          "details": "Form fields: email, password. Client-side validation: required fields, email format. Display appropriate error messages.",
          "status": "done"
        },
        {
          "id": 3,
          "title": "Implement API Communication for Auth Endpoints",
          "description": "Implement `fetch` API calls from the Svelte components (or a dedicated service) to interact with the backend `/auth/register` and `/auth/login` endpoints. Handle request submission and response processing.",
          "dependencies": [
            1,
            2
          ],
          "details": "Functions to call `/auth/register` with registration data and `/auth/login` with login credentials. Handle success responses (e.g., receiving a JWT) and error responses (e.g., displaying backend error messages).",
          "status": "done"
        },
        {
          "id": 4,
          "title": "Manage Client-Side Authentication State",
          "description": "Implement mechanisms for managing the client-side authentication state. This includes storing the JWT (e.g., in `localStorage` or `sessionStorage`) upon successful authentication and using Svelte stores to make the authentication status and user data globally accessible.",
          "dependencies": [
            3
          ],
          "details": "Create a Svelte store (e.g., `authStore.js`) to hold user object and token. Functions to save token to localStorage, load token from localStorage on app init, and clear token. Update store based on login/registration success.",
          "status": "done"
        },
        {
          "id": 5,
          "title": "Implement Logout and Conditional UI Rendering",
          "description": "Implement logout functionality that clears the authentication state (JWT from storage, Svelte store). Update the UI to render conditionally based on the user's authentication status (e.g., show user profile/logout vs. login/register links).",
          "dependencies": [
            4
          ],
          "details": "Create a logout function/button that clears the token from localStorage and resets the auth store. Implement route guards or conditional rendering in Svelte components (`{#if $authStore.isAuthenticated}`) to protect routes and show/hide UI elements.",
          "status": "done"
        }
      ]
    },
    {
      "id": 7,
      "title": "BE: Cryptocurrency Management API & Seed Data",
      "description": "Create backend API endpoints for managing simulated cryptocurrencies (e.g., list all, get details). Implement a Cryptocurrency model and database interactions. Seed the database with initial cryptocurrency data (e.g., SIM_BTC, SIM_ETH).",
      "details": "Create a `/cryptocurrencies` GET endpoint in Express to list all active cryptocurrencies from the `Cryptocurrencies` table. Implement model functions for `Cryptocurrency` (e.g., `getAllCryptocurrencies`). Create a seed script (SQL or Node.js) to populate `Cryptocurrencies` table with initial data like: `('SIM_BTC', 'Simulated Bitcoin', 'A simulated version of Bitcoin for trading practice', true)`, `('SIM_ETH', 'Simulated Ethereum', 'A simulated version of Ethereum', true)`.",
      "testStrategy": "API endpoint `/cryptocurrencies` returns a JSON array of seeded cryptocurrencies. Data should match what's in the database.",
      "priority": "medium",
      "dependencies": [
        2
      ],
      "status": "done",
      "subtasks": [
        {
          "id": 1,
          "title": "Define/Update Cryptocurrency Database Model",
          "description": "Create or update the data model/schema for cryptocurrencies. This includes defining fields such as ID, name, symbol, current_price, and any other relevant attributes for database storage and interaction.",
          "dependencies": [],
          "details": "Specify data types, constraints (e.g., unique, not null), and relationships for the Cryptocurrency entity. This model will be used by the API and seeding script. Ensure it aligns with requirements for listing active cryptocurrencies.",
          "status": "done"
        },
        {
          "id": 2,
          "title": "Implement GET /cryptocurrencies API Endpoint",
          "description": "Develop a GET API endpoint (e.g., `/api/cryptocurrencies`) that retrieves and returns a list of all active cryptocurrencies from the database. This endpoint will use the Cryptocurrency model defined in subtask 1.",
          "dependencies": [
            1
          ],
          "details": "The endpoint should interact with the database to fetch all records from the `Cryptocurrencies` table. Ensure it returns data in a standard JSON format. Implement logic to filter for 'active' cryptocurrencies if this is a requirement.",
          "status": "done"
        },
        {
          "id": 3,
          "title": "Develop Cryptocurrency Data Seeding Script",
          "description": "Create a script (e.g., SQL, Node.js, or using an ORM's seeding mechanism) to populate the `Cryptocurrencies` table with initial sample data. This data will be used for development and testing the API.",
          "dependencies": [
            1
          ],
          "details": "The script should insert a predefined list of common cryptocurrencies (e.g., Bitcoin, Ethereum, Litecoin) with their respective details into the database, adhering to the model/schema defined in subtask 1. Include data for fields like name, symbol, and an initial price.",
          "status": "done"
        }
      ]
    },
    {
      "id": 8,
      "title": "FE: Display Cryptocurrencies",
      "description": "Develop a Svelte component to fetch and display the list of available cryptocurrencies from the backend. This list will be used for users to select which market to view/trade.",
      "details": "Create a `CryptoList.svelte` component. In its `onMount` lifecycle function or a load function (SvelteKit), use `fetch` to GET data from the `/cryptocurrencies` backend endpoint. Display the symbols and names in a list or table. Allow selection of a cryptocurrency (this will be used later for trading views).",
      "testStrategy": "The frontend correctly fetches and displays the list of cryptocurrencies obtained from the backend API. Selection mechanism should be testable.",
      "priority": "medium",
      "dependencies": [
        5,
        7
      ],
      "status": "done",
      "subtasks": [
        {
          "id": 1,
          "title": "Create CryptocurrencyList component structure",
          "description": "Create a new Svelte component to display the list of cryptocurrencies with basic structure and imports.",
          "details": "",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 8
        },
        {
          "id": 2,
          "title": "Implement API fetch logic for cryptocurrencies",
          "description": "Add function to fetch cryptocurrency data from the backend /api/crypto/cryptocurrencies endpoint using fetch API.",
          "details": "",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 8
        },
        {
          "id": 3,
          "title": "Create UI template for cryptocurrency display",
          "description": "Design and implement the HTML template to display cryptocurrency list with proper styling and layout.",
          "details": "",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 8
        }
      ]
    },
    {
      "id": 9,
      "title": "BE: Account & CryptoHolding Models & Balance API",
      "description": "Implement backend models for `Accounts` (fiat) and `CryptoHoldings` (crypto). Create API endpoints for authenticated users to fetch their balances. Implement logic to seed initial simulated fiat (e.g., SIM_USD) and/or crypto balances for new users upon registration or first login.",
      "details": "Create `/account/balances` GET endpoint, protected by auth middleware. This endpoint should query `Accounts` and `CryptoHoldings` tables for the logged-in user (`req.user.id`). Return a consolidated list of balances. Implement logic (e.g., during user registration or a separate seeding function) to give new users a starting amount of 'SIM_USD' in their `Accounts` table and potentially some base simulated crypto in `CryptoHoldings`.",
      "testStrategy": "Authenticated users can fetch their balances via the API. New users should have default seeded balances. Balances should reflect database state.",
      "priority": "high",
      "dependencies": [
        2,
        4
      ],
      "status": "done",
      "subtasks": [
        {
          "id": 1,
          "title": "Implement Account and CryptoHolding Database Models & Services",
          "description": "Define database schemas and implement service layer logic for `Accounts` (fiat) and `CryptoHoldings` (crypto).",
          "dependencies": [],
          "details": "This includes defining all necessary fields, relationships, data types, and basic CRUD operations for both models. `Accounts` will manage fiat currency balances (e.g., SIM_USD), and `CryptoHoldings` will manage cryptocurrency balances.",
          "status": "done"
        },
        {
          "id": 2,
          "title": "Create Authenticated GET API for User Balances",
          "description": "Develop an authenticated GET API endpoint (e.g., `/account/balances`) to fetch combined fiat and crypto balances for the logged-in user.",
          "dependencies": [
            1
          ],
          "details": "The endpoint must integrate with the authentication system. It will query the `Accounts` and `CryptoHoldings` data, aggregating balances for the specific user making the request.",
          "status": "done"
        },
        {
          "id": 3,
          "title": "Implement New User Initial Balance Seeding Logic",
          "description": "Develop the backend logic to automatically seed initial fiat (e.g., SIM_USD) and/or crypto balances for new users upon successful registration.",
          "dependencies": [
            1
          ],
          "details": "This logic should be triggered during the user registration process. Specify the default amounts and types of currencies/cryptocurrencies to be credited to new user accounts.\n<info added on 2025-05-24T15:54:51.474Z>\nUpon new user registration, only an initial fiat balance (SIM_USD 10000.00) will be seeded into the 'accounts' table. No initial cryptocurrency balances will be seeded. The existing implementation in `server/routers/authRouter.js` correctly handles this fiat seeding.\n</info added on 2025-05-24T15:54:51.474Z>",
          "status": "done"
        },
        {
          "id": 4,
          "title": "Ensure Correct User ID Filtering in Balance API Queries",
          "description": "Implement and verify that all API queries for fetching balances correctly join and filter data by `user_id` to ensure data integrity and security.",
          "dependencies": [
            2
          ],
          "details": "This involves rigorous testing of the `/account/balances` endpoint to confirm that it only returns data belonging to the authenticated user, preventing any cross-user data exposure. Review query construction for `Accounts` and `CryptoHoldings`.",
          "status": "done"
        }
      ]
    },
    {
      "id": 10,
      "title": "FE: Display Account Balances",
      "description": "Create Svelte components to display the authenticated user's fiat and cryptocurrency balances, fetched from the backend API.",
      "details": "Create an `AccountDashboard.svelte` or similar component. When the component mounts and the user is authenticated, use `fetch` to GET data from `/account/balances`. Display the balances clearly, separating fiat and different cryptocurrencies.",
      "testStrategy": "Logged-in user sees their correct fiat and crypto balances displayed. If no balances, an appropriate message is shown. Updates if balances change (e.g., after a trade, to be tested later).",
      "priority": "high",
      "dependencies": [
        6,
        9
      ],
      "status": "done",
      "subtasks": [
        {
          "id": 1,
          "title": "Create Account Dashboard Component Shell",
          "description": "Develop the basic structure for the `AccountDashboard.svelte` component (or equivalent for the chosen frontend framework). This component will serve as the container for displaying account balances.",
          "dependencies": [],
          "details": "Focus on creating the file, basic HTML/Svelte structure, and any necessary initial styling placeholders. No data fetching or display logic at this stage.",
          "status": "done"
        },
        {
          "id": 2,
          "title": "Implement Balance Fetching Logic",
          "description": "Implement the client-side logic to make authenticated API calls to the backend to retrieve the user's fiat and crypto account balances. This includes handling API responses and errors.",
          "dependencies": [
            1
          ],
          "details": "This logic might reside within the `AccountDashboard.svelte` component (e.g., in its script section or a lifecycle function) or in a separate service/store that the component consumes. Ensure proper handling of authentication tokens and API error states (e.g., network issues, unauthorized).",
          "status": "done"
        },
        {
          "id": 3,
          "title": "Display Balances in UI with Edge Case Handling",
          "description": "Integrate the fetched balance data into the `AccountDashboard.svelte` component's template. Clearly display the various fiat and crypto balances, and implement UI to handle cases such as zero balances, non-existent balances (if applicable), loading states, and error states from fetching.",
          "dependencies": [
            1,
            2
          ],
          "details": "Consider formatting for currency and cryptocurrency values. Implement user-friendly messages for loading, errors, or when no balances are available. Ensure the UI is responsive and accessible.",
          "status": "done"
        }
      ]
    },
    {
      "id": 11,
      "title": "BE: Order & Trade Models & DB Schema",
      "description": "Define and implement database schema for `Orders` and `Trades` within the existing `createDb.js` script. `Orders` will store user's buy/sell orders. `Trades` will record executed transactions between users.",
      "status": "done",
      "dependencies": [
        2
      ],
      "priority": "high",
      "details": "Extend DB schema by defining `Orders` and `Trades` tables within `createDb.js`. `Orders` (order_id PK, user_id FK, cryptocurrency_id FK, type ('buy'/'sell'), order_type ('limit'/'market'), quantity_total DECIMAL, quantity_remaining DECIMAL, price DECIMAL, status ('open', 'partially_filled', 'fully_filled', 'cancelled'), created_at, updated_at). `Trades` (trade_id PK, buy_order_id FK, sell_order_id FK, cryptocurrency_id FK, quantity DECIMAL, price DECIMAL, buyer_user_id FK, seller_user_id FK, trade_timestamp). The `createDb.js` script will handle schema creation, dropping, and resetting; formal versioned migration tool integration is not planned for this task.",
      "testStrategy": "Verify `Orders` and `Trades` tables are created correctly in the database with all specified fields and constraints by running the `createDb.js` script. Ensure the script can successfully drop and recreate these tables.",
      "subtasks": []
    },
    {
      "id": 12,
      "title": "BE: Order Placement API (Limit Orders)",
      "description": "Implement a backend API endpoint for users to place new buy or sell orders, supporting both 'limit' and 'market' order types as per the updated request structure. This endpoint must validate the order through a 4-layer architecture (Input Validation, Business Rules Validation, Balance Validation, Error Handling) and, if valid, store it in the `Orders` table with an 'open' status. The request structure is { cryptocurrency_id, type, order_type, quantity, price (optional for market orders) }.",
      "status": "deferred",
      "dependencies": [
        4,
        9,
        11,
        "31",
        "32",
        "33"
      ],
      "priority": "high",
      "details": "Create `POST /orders` endpoint (as per REST conventions, protected by auth middleware). \nRequest body: `{ cryptocurrency_id: int, type: 'buy'/'sell', order_type: 'limit'/'market', quantity: float, price: float (required for 'limit' orders, optional for 'market' orders) }`.\n\nBackend Logic (4-Layer Validation Architecture):\n1.  **Layer 1: Input Validation (No Database Calls)**: Validate data types, required fields (price is conditional on `order_type`), and formats (e.g., positive numbers for quantity/price, valid enum values for type/order_type).\n2.  **Layer 2: Business Rules Validation (Lightweight DB Calls)**: Check `cryptocurrency_id` existence in the `cryptocurrencies` table. Basic validation of quantity/price (e.g. positive values, though primarily handled in Layer 1).\n3.  **Layer 3: Balance Validation (Critical Financial Check)**:\n    *   If 'buy' order: Check user's SIM_USD balance in the `accounts` table. For limit orders, ensure `balance >= quantity * price`. (Market order cost estimation for balance check needs separate clarification if fully implemented under this task).\n    *   If 'sell' order: Check user's relevant cryptocurrency balance in the `crypto_holdings_base` table, ensuring `crypto_balance >= quantity`.\n4.  **Order Creation**: If all validations pass, create a new record in the `Orders` table with status 'open', `quantity_remaining = quantity_total`, and include `order_type`.\n5.  **Layer 4: Error Handling & Response**: Respond with success or a standardized JSON error (using HTTP status codes like 400, 422, 500) providing detailed messages.",
      "testStrategy": "Authenticated users can submit valid limit and market orders. Orders are stored correctly in the DB, including `order_type` and appropriate `price` (null for market if not provided). \nLayer 1 Validations: Test rejections for invalid data types, missing required fields (e.g., price for limit order, or `order_type`), invalid enum values, non-positive quantity/price. \nLayer 2 Validations: Test rejections for non-existent `cryptocurrency_id`. \nLayer 3 Validations: Test rejections for insufficient SIM_USD (buy orders) or crypto (sell orders) balance. Verify correct tables (`accounts`, `crypto_holdings_base`) are checked. \nLayer 4 Validations: Ensure standardized JSON error responses with correct HTTP status codes (400, 422, 500) for all failure scenarios. Test successful order placement for both 'buy' and 'sell' types, and for 'limit' and 'market' order types.",
      "subtasks": [
        {
          "id": 1,
          "title": "Define POST /orders/ Endpoint and Basic Structure",
          "description": "Create the Express route for `POST /orders/`. Integrate existing authentication middleware to protect the endpoint. Set up the basic request handler structure within the appropriate Express router.",
          "dependencies": [],
          "details": "This involves: 1. Locating or creating the relevant Express router file (e.g., `orderRoutes.js`). 2. Defining the `POST /orders/` route, adhering to RESTful conventions. 3. Applying the project's standard authentication middleware to this route. 4. Creating an initial placeholder controller/handler function for this route.\n<info added on 2025-05-25T15:00:29.180Z>\nUsing RESTful POST /orders/ endpoint instead of /orders/place as this follows proper REST conventions. The basic structure is already in place in orderRouter.js with authentication middleware applied.\n</info added on 2025-05-25T15:00:29.180Z>",
          "status": "done"
        },
        {
          "id": 2,
          "title": "Implement Layer 1 & 2 Validation (Input & Business Rules)",
          "description": "Develop and integrate server-side validation for the order placement request body, covering Layer 1 (Input Validation - no DB calls) and Layer 2 (Business Rules Validation - lightweight DB calls). This includes `cryptocurrency_id`, `type`, `order_type`, `quantity`, and `price`.",
          "dependencies": [
            1
          ],
          "details": "This involves:\n**Layer 1: Input Validation (No Database Calls)**\n1.  Validate data types for all fields: `cryptocurrency_id` (integer), `type` (string), `order_type` (string), `quantity` (number), `price` (number, if present).\n2.  Validate required fields: `cryptocurrency_id`, `type`, `order_type`, `quantity` are always required.\n3.  Conditional `price` validation: `price` is required if `order_type` is 'limit'; optional if `order_type` is 'market'. If provided for market, it might be ignored or used as a ceiling, per system design.\n4.  Validate enum values: `type` must be 'buy' or 'sell'. `order_type` must be 'limit' or 'market'.\n5.  Validate numeric formats: `quantity` must be a positive number. `price` (if provided) must be a positive number. Adhere to any precision/min/max rules.\n\n**Layer 2: Business Rules Validation (Lightweight DB Calls)**\n1.  Validate `cryptocurrency_id`: Ensure it exists in the `cryptocurrencies` table.\n2.  Basic quantity/price validation (e.g., positive values) - primarily covered in Layer 1, re-verify if any DB-dependent rules apply here (e.g., lot sizes, tick sizes if defined).\n\nEnsure validation errors from both layers lead to appropriate early responses (e.g., HTTP 400 Bad Request or 422 Unprocessable Entity).",
          "status": "deferred"
        },
        {
          "id": 3,
          "title": "Implement Layer 3: Balance Validation",
          "description": "Create logic for Layer 3 (Balance Validation) to check the authenticated user's available balance. For 'buy' orders, check SIM_USD balance in the `accounts` table. For 'sell' orders, check the relevant cryptocurrency balance in the `crypto_holdings_base` table.",
          "dependencies": [
            2
          ],
          "details": "This involves:\n1.  Retrieving the authenticated user's ID (from the auth middleware).\n2.  For 'buy' orders:\n    a.  Query the `accounts` table for the user's available SIM_USD balance.\n    b.  If `order_type` is 'limit', ensure `available_SIM_USD_balance >= quantity * price`.\n    c.  If `order_type` is 'market', the mechanism for determining the funds to hold (e.g., based on quantity and current market price or a buffer) needs to be defined. For this task, prioritize limit order logic.\n3.  For 'sell' orders:\n    a.  Query the `crypto_holdings_base` table for the user's available balance of the specified `cryptocurrency_id`.\n    b.  Ensure `available_crypto_balance >= quantity`.\n4.  Ensure the balance check considers only *available* funds (e.g., not funds locked in other open orders).\n5.  This logic is critical and should be callable from the order placement handler after Layer 1 and Layer 2 validations pass. If balance is insufficient, respond with an appropriate error (e.g., HTTP 400 or 422).",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Implement Order Creation in PostgreSQL Database",
          "description": "If all validations (Layers 1-3) pass and the user has sufficient funds, implement the logic to create a new order record in the `Orders` table in the PostgreSQL database with an initial status of 'open'. Include `order_type` in the stored record.",
          "dependencies": [
            3
          ],
          "details": "This involves:\n1.  Constructing the data object for the new order, including `user_id`, `cryptocurrency_id`, `type` (buy/sell), `order_type` (limit/market), `quantity_total` (from request `quantity`), `price` (from request `price` for limit orders; can be null for market orders if not provided or not applicable at creation), `status` ('open'), and `quantity_remaining` (initially equal to `quantity_total`), `created_at` (timestamp).\n2.  Using the project's database access layer (e.g., ORM, query builder, or raw SQL client) to insert the new record into the `Orders` table.\n3.  Ensure the operation is robust. Consider if this operation should be part of a larger transaction if funds are to be locked/deducted simultaneously (though fund movement might be handled by a separate ledger service or subsequent step).",
          "status": "pending"
        },
        {
          "id": 5,
          "title": "Implement Layer 4: Error Handling and Response Formatting",
          "description": "Ensure robust error handling throughout the order placement process as per Layer 4. Provide clear, standardized JSON error responses for various failure scenarios, using appropriate HTTP status codes (e.g., 400, 422, 500).",
          "dependencies": [
            2,
            3,
            4
          ],
          "details": "This involves:\n1.  Defining or adhering to a project-wide standardized JSON error response format (e.g., `{ \"error\": { \"message\": \"...\", \"code\": \"...\" } }`).\n2.  Handling errors from Layer 1 & 2 (Input and Business Rule Validation) with HTTP 400 (Bad Request) or HTTP 422 (Unprocessable Entity) for client-side errors. Include detailed messages indicating which field or rule failed.\n3.  Handling errors from Layer 3 (Balance Validation - e.g., insufficient funds) with an appropriate HTTP status (e.g., HTTP 400 or 422), with a clear message.\n4.  Handling potential errors during database interaction (Order Creation in Subtask 4) with HTTP 500 (Internal Server Error) for unexpected server-side issues.\n5.  Ensuring all success responses (e.g., HTTP 201 Created for new order) also follow a consistent format, returning relevant information about the created order.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 13,
      "title": "FE: Trading Form & My Open Orders Display",
      "description": "Develop Svelte components for a trading form (select crypto, buy/sell, quantity, price) and a display area for the user's currently open orders. Orders submitted via the form should be sent to the backend API.",
      "details": "Create `TradingForm.svelte` component. Inputs for cryptocurrency selection (dropdown populated from crypto list), order type (buy/sell buttons), quantity, price. On submit, `fetch` POST to `/orders/place`. Create `MyOpenOrders.svelte` component. Fetch user's open orders from a new backend endpoint (e.g., `/orders/mine`) and display them in a table.",
      "testStrategy": "User can fill and submit the trading form. Order data is sent to backend. User's open orders are fetched and displayed correctly. Client-side validation for form inputs.",
      "priority": "high",
      "dependencies": [
        6,
        8,
        10,
        12,
        "31",
        "32",
        "33"
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 14,
      "title": "BE: WebSocket Server Integration",
      "description": "Integrate a WebSocket server (e.g., `ws` library or `socket.io`) into the Express backend. Handle basic client connections and disconnections.",
      "details": "Install `ws` (`npm install ws`). Integrate with existing HTTP server: `const WebSocket = require('ws'); const server = http.createServer(app); const wss = new WebSocket.Server({ server }); wss.on('connection', ws => { console.log('Client connected'); ws.on('message', message => console.log('received: %s', message)); ws.on('close', () => console.log('Client disconnected')); }); server.listen(PORT, ...);`. This sets up the WebSocket server alongside Express.",
      "testStrategy": "WebSocket server starts with the HTTP server. Client can connect to the WebSocket endpoint. Connection/disconnection events are logged on the server.",
      "priority": "high",
      "dependencies": [
        1
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 15,
      "title": "FE: WebSocket Client Integration",
      "description": "Implement Socket.IO client logic in the Svelte frontend to connect to the backend Socket.IO server. Handle connection establishment and receive 'orderBookUpdate' events containing Binance market data.",
      "status": "done",
      "dependencies": [
        5,
        14
      ],
      "priority": "high",
      "details": "Integrate the Socket.IO client library (`socket.io-client`) into the Svelte frontend. In a Svelte store or a suitable client-side component (e.g., `+layout.svelte` or a dedicated service), establish a Socket.IO connection: `import { io } from 'socket.io-client'; const socket = io('http://localhost:8080'); socket.on('connect', () => console.log('Connected to Socket.IO server')); socket.on('disconnect', () => console.log('Disconnected from Socket.IO server')); socket.on('orderBookUpdate', (data) => console.log('Order book update:', data));`. Ensure this runs client-side. The backend already logs user connections/disconnections, so frontend logging for these events is primarily for client-side debugging.",
      "testStrategy": "Svelte frontend successfully connects to the backend Socket.IO server at 'http://localhost:8080'. Console logs confirm connection. Verify that 'orderBookUpdate' events are received and that the payload contains Binance market data. Backend logs should also show client connection/disconnection.",
      "subtasks": [
        {
          "id": 1,
          "title": "Install socket.io-client library",
          "description": "Install the socket.io-client library in the frontend project to enable Socket.IO communication.",
          "details": "",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 15
        },
        {
          "id": 2,
          "title": "Create Socket.IO store structure",
          "description": "Create socketStore.js with writable stores for socket connection, connection status, and order book data. Include connectSocket and disconnectSocket functions.",
          "details": "",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 15
        },
        {
          "id": 3,
          "title": "Implement connection and disconnect event listeners",
          "description": "Add event listeners for 'connect' and 'disconnect' events, logging connection status to the browser console and updating the isConnected store.",
          "details": "",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 15
        },
        {
          "id": 4,
          "title": "Implement orderBookUpdate event listener",
          "description": "Add event listener for 'orderBookUpdate' events, logging the received Binance market data to the browser console and updating the orderBookData store.",
          "details": "",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 15
        }
      ]
    },
    {
      "id": 16,
      "title": "BE: In-Memory Order Book Implementation",
      "description": "Design and implement in-memory data structures on the backend to hold the live order book for each cryptocurrency pair (e.g., bids and asks sorted by price). Implement logic to add new orders (from the Order Placement API) to this in-memory book and remove/update them when they are matched or cancelled. Refer to `depthcache-documentation.md` for potential strategies.",
      "details": "Create a service/module for managing order books, e.g., `OrderBookService.js`. For each trading pair (e.g., 'SIM_BTC/SIM_USD'), maintain two sorted lists/arrays: one for bids (buy orders, sorted high to low price) and one for asks (sell orders, sorted low to high price). Each entry should store price, quantity, timestamp, order_id. When a new order comes from `/orders/place` and isn't immediately matched, add it to the appropriate side of the book. Consider using efficient data structures if performance becomes a concern (e.g., balanced trees or heaps, though arrays with sorting might suffice for simulation). The `depthcache-documentation.md` might provide insights on structure and management.",
      "testStrategy": "New orders are correctly added to the in-memory order book, maintaining price-time priority. Test adding buy and sell orders at various prices and quantities. Verify internal state of the order book.",
      "priority": "high",
      "dependencies": [
        11,
        12
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 17,
      "title": "BE: Order Matching Engine Development",
      "description": "Develop the core order matching engine logic. This engine will take an incoming order and attempt to match it against resting orders in the in-memory order book based on price-time priority. It should handle partial and full fills. Refer to `depthcache-documentation.md` for potential strategies.",
      "details": "In `OrderBookService.js` or a dedicated `MatchingEngine.js`. When a new order arrives: If buy order, iterate through asks (lowest price first). If sell order, iterate through bids (highest price first). If prices cross/match: determine fill quantity (min of incoming order qty and resting order qty). If partial fill, update remaining quantity of the involved order(s). If full fill, mark order(s) for removal. Price-time priority: match best price first; if multiple orders at best price, match oldest first (FIFO based on timestamp).",
      "testStrategy": "Test various scenarios: new buy order matching existing sell order(s), new sell matching existing buy(s). Test partial fills, multiple fills for one incoming order, and orders that don't match and get added to the book. Verify price-time priority.",
      "priority": "high",
      "dependencies": [
        16
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 18,
      "title": "BE: Trade Execution & State Updates",
      "description": "Implement the logic for when a trade occurs (match found by the engine). This includes: atomically updating user balances in the database (debit/credit fiat and crypto), creating a `Trade` record, and updating the status of involved `Order` records in the database and in-memory order book.",
      "details": "When matching engine finds a match: 1. Start a database transaction. 2. Debit buyer's fiat, credit seller's fiat. Debit seller's crypto, credit buyer's crypto. Update `Accounts` and `CryptoHoldings` tables. 3. Create a new record in `Trades` table (buyer_id, seller_id, crypto_id, quantity, price, timestamp). 4. Update `Orders` table: change status (e.g., 'partially_filled', 'fully_filled'), decrease `quantity_remaining`. 5. Commit transaction. 6. Update/remove orders from the in-memory order book. Ensure atomicity for balance updates.",
      "testStrategy": "Verify that after a trade: user balances are correctly updated in DB. A trade record is created. Order statuses and remaining quantities are updated in DB and in-memory book. Database transactions ensure atomicity (all updates succeed or all fail).",
      "priority": "high",
      "dependencies": [
        9,
        11,
        17
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 19,
      "title": "BE: Real-time Order Book Broadcasting",
      "description": "When the in-memory order book changes (order added, trade occurs, order cancelled), broadcast these updates via WebSockets to all connected and subscribed frontend clients. Decide on data format (full book snapshot or deltas).",
      "details": "Modify `OrderBookService.js` or `MatchingEngine.js`. After any change to an order book (new order added, order filled/cancelled): serialize the current state of the relevant order book (e.g., top N bids/asks for a specific crypto pair). Broadcast this data over WebSockets to clients subscribed to that pair. Message format example: `{ type: 'ORDER_BOOK_UPDATE', pair: 'SIM_BTC/SIM_USD', data: { bids: [...], asks: [...] } }`. Initially, sending a snapshot of the visible part of the book is simpler than deltas.",
      "testStrategy": "Frontend clients receive WebSocket messages when the order book changes. The data received should reflect the current state of the order book on the server for the subscribed pair.",
      "priority": "high",
      "dependencies": [
        14,
        16,
        18
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 20,
      "title": "FE: Real-time Order Book Visualization",
      "description": "Create a Svelte component to visualize the live order book (bids and asks). This component should subscribe to WebSocket updates for the selected cryptocurrency pair and efficiently re-render the display when new data arrives.",
      "details": "Create `OrderBook.svelte` component. Props: `selectedPair`. On component mount or when `selectedPair` changes: send a WebSocket message to subscribe to that pair's order book updates (if backend requires explicit subscription). Listen for `ORDER_BOOK_UPDATE` messages. When data arrives, update local Svelte stores or component state for bids and asks. Render two lists (bids in green, asks in red), sorted by price, showing price, quantity, and cumulative quantity. Use Svelte's reactivity for efficient DOM updates (`{#each ... key=...}`).",
      "testStrategy": "Order book display updates in near real-time when orders are placed or matched on the backend. Bids and asks are displayed correctly, sorted, and styled. Performance should be acceptable.",
      "priority": "high",
      "dependencies": [
        8,
        15,
        19
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 21,
      "title": "BE: Real-time User Notifications Service",
      "description": "Implement a backend service to send targeted real-time notifications (e.g., order filled, order partially filled, insufficient funds, balance updates) to specific users via WebSockets.",
      "details": "Maintain a mapping of connected WebSocket clients to user IDs (e.g., store `userId` on `ws` object after authentication via socket, or have clients send their JWT for initial socket auth). When an event occurs (e.g., order fill from `TradeExecution`): identify the relevant user(s). Send a targeted WebSocket message. Example: `{ type: 'USER_NOTIFICATION', message: 'Your buy order for 1 SIM_BTC at 10000 SIM_USD was filled.', details: {...} }` or `{ type: 'BALANCE_UPDATE', currency: 'SIM_USD', newBalance: 5000 }`.",
      "testStrategy": "Specific users receive notifications relevant to their actions (e.g., trade confirmations, balance changes). Other users do not receive these notifications. Messages are correctly formatted.",
      "priority": "medium",
      "dependencies": [
        14,
        18
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 22,
      "title": "FE: Display Real-time User Notifications",
      "description": "Develop frontend logic to listen for user-specific WebSocket notifications and display them to the user (e.g., as toast messages or in a notification feed). Dynamically update displayed balances if a balance update notification is received.",
      "details": "In Svelte client, listen for `USER_NOTIFICATION` and `BALANCE_UPDATE` messages. For `USER_NOTIFICATION`, display the message using a toast component (e.g., `svelte-toast`) or add to a list. For `BALANCE_UPDATE`, update the Svelte store holding user balances, which should reactively update the UI (e.g., `AccountDashboard.svelte`).",
      "testStrategy": "User sees notifications for their own trade events. Balances displayed on the dashboard update automatically when a balance notification is received via WebSocket.",
      "priority": "medium",
      "dependencies": [
        10,
        15,
        21
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 23,
      "title": "BE/FE: Stripe Integration for Simulated Fiat Deposits",
      "description": "Integrate Stripe for simulated fiat deposits. Frontend: use Stripe Elements to collect test card details and get a payment token. Backend: API endpoint to receive token, use Stripe Node.js SDK to create a test charge. On success, update user's fiat balance in `Accounts` table and create a `Transaction` record.",
      "details": "FE: Add 'Deposit Fiat' section. Use `@stripe/stripe-js` and `@stripe/react-stripe-js` (or Svelte equivalent for Stripe Elements). Collect amount, use Stripe Elements for card form. On submit, call `stripe.createPaymentMethod()` or `stripe.confirmCardPayment()`. Send paymentMethodId/token and amount to backend. BE: `/payments/stripe-deposit` POST endpoint. Use `stripe` Node.js library (`npm install stripe`). `stripe.paymentIntents.create({ amount, currency: 'usd', payment_method, confirm: true })` with test keys. On success: update user's 'SIM_USD' balance in `Accounts`. Create a `Transactions` record (user_id, type='deposit_fiat', currency_code='SIM_USD', amount, status='completed', external_transaction_id=stripe_charge_id). The `Transactions` table schema needs to be defined (similar to PRD: transaction_id, user_id, type, currency_code_or_crypto_id, amount, status, external_transaction_id, timestamp).",
      "testStrategy": "User can go through Stripe test payment flow. Successful test payment updates user's fiat balance on backend and in UI. A transaction record is created. Stripe dashboard shows test transaction.",
      "priority": "medium",
      "dependencies": [
        4,
        9,
        11
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 24,
      "title": "BE/FE: Crypto Wallet Integration - Simulated Deposits",
      "description": "Implement basic crypto wallet integration for simulated deposits. Frontend: display a unique (or shared for simulation) testnet deposit address for a selected crypto. Backend: mechanism to (manually or via script) monitor this address on a testnet (e.g., Sepolia for ETH, Solana testnet for SOL). On detecting a 'deposit', credit user's `CryptoHolding` balance and create a `Transaction` record.",
      "details": "FE: 'Deposit Crypto' section. User selects crypto (e.g., 'SIM_ETH_Sepolia'). Display a fixed testnet address controlled by the application. BE: For simulation, this might be a manual process initially: admin checks testnet explorer (Etherscan Sepolia) for incoming transactions to the exchange's address. If a deposit is confirmed, admin manually triggers an API endpoint or DB update to credit user's `CryptoHoldings` for the specific crypto and create a `Transactions` record (type='deposit_crypto'). More advanced: script using `ethers.js` or `@solana/web3.js` to periodically query balance/transactions for the exchange's address.",
      "testStrategy": "User is shown a deposit address. After simulating a testnet transfer to this address, their simulated crypto balance is updated on the platform (manually or via script). A transaction record is created.",
      "priority": "low",
      "dependencies": [
        4,
        9,
        11,
        23
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 25,
      "title": "BE/FE: Crypto Wallet Integration - Simulated Withdrawals",
      "description": "Implement basic crypto wallet integration for simulated withdrawals. Frontend: form for withdrawal address and amount. Backend: API to receive request, check balance, simulate transfer (log it, no actual testnet transaction unless time permits), debit user's `CryptoHolding` balance, and create a `Transaction` record.",
      "details": "FE: 'Withdraw Crypto' section. User selects crypto, enters amount and their external testnet wallet address. Submit to backend. BE: `/wallet/initiate-withdrawal` POST endpoint. Validate user has sufficient balance in `CryptoHoldings`. If yes: debit balance. Create `Transactions` record (type='withdrawal_crypto', status='pending' or 'completed' for simulation). For actual testnet transaction (advanced): use `ethers.js` or `@solana/web3.js` with exchange's private key to send funds. For simulation, just log the intent.",
      "testStrategy": "User can request a withdrawal. If sufficient balance, simulated balance is debited. A transaction record is created. If actual testnet tx implemented, verify on explorer.",
      "priority": "low",
      "dependencies": [
        4,
        9,
        11,
        23,
        24
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 26,
      "title": "BE/FE: Trade History Feature",
      "description": "Develop a feature for users to view their trade history. Backend: API endpoint to fetch all trades for the authenticated user from the `Trades` table. Frontend: Display this history in a clear, tabular format.",
      "details": "BE: `/trades/history` GET endpoint, protected by auth. Query `Trades` table for records where `buyer_user_id` or `seller_user_id` matches `req.user.id`. Return list of trades (pair, type (buy/sell from user's perspective), quantity, price, timestamp). FE: `TradeHistory.svelte` component. Fetch data from `/trades/history`. Display in a table.",
      "testStrategy": "User can view their past trades. Data should be accurate and match records in the `Trades` table. Display should clearly indicate if user was buyer or seller for each trade.",
      "priority": "medium",
      "dependencies": [
        4,
        18
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 27,
      "title": "BE/FE: (Optional) Admin Panel Basics",
      "description": "If time permits, implement basic admin functionalities. This could include a simple UI and corresponding backend APIs for an 'admin' role to view all users, manage list of tradable cryptocurrencies (add/edit/disable), or view system-wide trade statistics.",
      "details": "BE: Define 'admin' role in `Users` table. Create admin-only routes protected by authorization middleware (e.g., `/admin/users`, `/admin/cryptocurrencies`). Implement logic for admin actions. FE: Create separate admin section/components, visible only to admin users. Display relevant data and provide forms for admin actions.",
      "testStrategy": "Admin user can log in and access admin panel. Non-admin users cannot. Admin actions (e.g., disabling a cryptocurrency) reflect correctly in the system.",
      "priority": "low",
      "dependencies": [
        4,
        7
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 28,
      "title": "FE: UI/UX Styling & Refinement",
      "description": "Apply consistent styling across the Svelte application. Focus on clarity, simplicity, and usability, especially for the target 'Curious Learner' persona. Ensure basic responsiveness and address the 'attempt at styling' soft requirement. Consider a lightweight CSS framework or custom CSS.",
      "details": "Use global CSS styles or component-scoped styles in Svelte. Choose a color scheme, typography. Ensure consistent layout for forms, tables, navigation. Make interactive elements clear. Test on common desktop screen sizes. Consider using Pico.CSS, OpenProps, or custom CSS for a clean look. Focus on readability of order book and trading forms.",
      "testStrategy": "Application has a consistent and presentable visual appearance. Key user flows are intuitive. No major layout issues on desktop. Meets 'attempt at styling' requirement.",
      "priority": "medium",
      "dependencies": [
        5,
        6,
        8,
        10,
        13,
        20,
        22,
        23,
        24,
        25,
        26
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 29,
      "title": "ALL: GDPR Compliance Implementation",
      "description": "Implement GDPR compliance measures. This includes data minimization in logging and data storage, providing a clear privacy statement/policy page, and outlining (or implementing stubs for) how user data requests (export, deletion) would be handled. This is a 'production ready' hard requirement.",
      "details": "Review all data stored and logged; ensure only necessary data is kept. Create a static `PrivacyPolicy.svelte` page outlining data usage, storage, user rights. For data export/deletion: plan the process. For MVP, this might be a statement that users can contact support, and backend stubs for admin to manually process requests. Ensure user consent for cookies/tracking if any are used beyond essential session management.",
      "testStrategy": "Privacy policy page is accessible. Data handling practices reviewed for minimization. Plan for data subject requests is documented. No unnecessary personal data logged.",
      "priority": "high",
      "dependencies": [
        28
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 30,
      "title": "ALL: Final Testing, Code Cleanup & Documentation",
      "description": "Conduct comprehensive end-to-end testing of all user flows and features. Remove all `console.log` statements, unused code, and unfinished snippets. Ensure code style is consistent. Write or update documentation for key architectural decisions and setup. Prepare for showcasing the application.",
      "details": "Manually test all user flows: registration, login, viewing markets, placing orders, trade execution, balance updates, notifications, deposits/withdrawals, trade history. Fix any bugs. Search codebase for `console.log` and remove. Delete commented-out code blocks and unused files/functions. Run linters/formatters. Document database schema, API endpoints, and any complex logic (e.g., matching engine). Prepare demo script for exam.",
      "testStrategy": "All features work as expected. Codebase is clean and meets 'production ready' requirements. Documentation is sufficient for understanding the project. Application is ready for demonstration.",
      "priority": "high",
      "dependencies": [
        29
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 31,
      "title": "BE: OpenAPI Specification Compliance",
      "description": "Refactor all API endpoints to comply with OpenAPI specifications",
      "details": "Create OpenAPI specification document and ensure all endpoints follow standards for request/response formats, status codes, error responses, and data schemas. Add validation middleware and documentation generation.",
      "testStrategy": "",
      "status": "pending",
      "dependencies": [
        1,
        2,
        3,
        4,
        "33"
      ],
      "priority": "high",
      "subtasks": []
    },
    {
      "id": 32,
      "title": "BE: Error Handling Architecture Refactor",
      "description": "Remove all error handling from services and repositories, centralizing it in routers",
      "details": "Refactor the backend architecture to move all try-catch blocks and error handling logic from service and repository layers to their respective routers. Services and repositories should throw errors and let routers handle HTTP responses and status codes.",
      "testStrategy": "",
      "status": "done",
      "dependencies": [
        1,
        2,
        3,
        4
      ],
      "priority": "high",
      "subtasks": [
        {
          "id": 1,
          "title": "Audit Current Error Handling in Services and Repositories",
          "description": "Review all existing service and repository files to identify current error handling patterns and try-catch blocks that need to be moved to routers",
          "details": "",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 32
        },
        {
          "id": 2,
          "title": "Refactor User Services to Remove Error Handling",
          "description": "Remove try-catch blocks from user services and let them throw errors instead",
          "details": "",
          "status": "done",
          "dependencies": [
            1
          ],
          "parentTaskId": 32
        },
        {
          "id": 3,
          "title": "Refactor Other Services (Crypto, Account, Order) to Remove Error Handling",
          "description": "Remove try-catch blocks from cryptocurrency, account, and order services",
          "details": "",
          "status": "done",
          "dependencies": [
            1
          ],
          "parentTaskId": 32
        },
        {
          "id": 4,
          "title": "Update All Routers with Centralized Error Handling",
          "description": "Add proper try-catch blocks and error handling to all router files to handle errors thrown by services",
          "details": "",
          "status": "done",
          "dependencies": [
            2,
            3
          ],
          "parentTaskId": 32
        },
        {
          "id": 5,
          "title": "Test and Verify Error Handling Refactor",
          "description": "Test all endpoints to ensure error handling works correctly and consistently across all routers",
          "details": "<info added on 2025-06-01T14:09:48.577Z>\nSuccessfully identified and fixed authentication middleware OpenAPI compliance issue. Authentication error handling now works correctly:\n\nFixed authentication middleware to use sendUnauthorized helper.\nVerified accounts endpoint returns proper 401 with error object.\nVerified orders endpoint returns proper 401 with error object.\nRemoved hardcoded authentication bypass (completed Task 35).\n\nThe error handling refactor is working correctly. All routers have comprehensive try-catch blocks and proper error response formatting.\n</info added on 2025-06-01T14:09:48.577Z>\n<info added on 2025-06-01T14:11:53.726Z>\nCompleted comprehensive error handling verification across all routers:\n\nAuthentication Errors: 401 responses with proper error format\nValidation Errors: 400/422 responses for OpenAPI and custom validation\nBusiness Logic Errors: 409 for conflicts, 422 for custom business rules\nResource Not Found: 404 responses with proper error messages\nInput Validation: 400 responses for malformed parameters\nAuthenticated Endpoints: Proper success responses with valid sessions\nAuthenticated Error Handling: 404 errors work correctly in authenticated context\n\nAll routers consistently use proper error response format:\n{\n  \"error\": \"ErrorType\",\n  \"message\": \"Descriptive error message\"\n}\n\nStatus codes are appropriate:\n- 400: Bad Request (OpenAPI validation)\n- 401: Unauthorized (authentication required)\n- 404: Not Found (resource doesn't exist)\n- 409: Conflict (duplicate resources)\n- 422: Unprocessable Entity (business rule violations)\n\nError handling refactor is complete and working perfectly.\n</info added on 2025-06-01T14:11:53.726Z>",
          "status": "done",
          "dependencies": [
            4
          ],
          "parentTaskId": 32
        }
      ]
    },
    {
      "id": 33,
      "title": "BE: Validation Schemas Implementation",
      "description": "Create comprehensive validation schemas for all existing features using a validation library",
      "details": "Implement validation schemas for all existing backend features including users, auth, cryptocurrencies, accounts, and orders. Choose and integrate a validation library (e.g., Joi, Yup, or Zod) and create reusable validation schemas for request bodies, query parameters, and response data. This includes validation for registration, login, cryptocurrency data, account balances, and order placement.",
      "testStrategy": "",
      "status": "pending",
      "dependencies": [
        1,
        2,
        3,
        4
      ],
      "priority": "high",
      "subtasks": []
    },
    {
      "id": 34,
      "title": "BE: API Key Authentication System",
      "description": "Implement API key generation and authentication system for API access",
      "details": "Create a system for generating, managing, and authenticating API keys for external access to the trading platform APIs. This includes API key generation endpoints, storage in database, middleware for API key validation, and rate limiting per API key. This is a non-urgent enhancement for future API access management.",
      "testStrategy": "",
      "status": "pending",
      "dependencies": [
        4,
        31,
        32,
        33
      ],
      "priority": "low",
      "subtasks": []
    },
    {
      "id": 35,
      "title": "BE: Fix Authentication Middleware Security Bypass",
      "description": "Remove hardcoded authentication bypass from backend/shared/middleware/authorisation.js. The middleware currently hardcodes userId=1 and role='admin' for all requests instead of validating sessions. This creates a critical security vulnerability.",
      "details": "1. Remove the hardcoded authentication bypass (lines 9-14 in authorisation.js)\n2. Uncomment and restore the proper session validation logic (lines 2-8)\n3. Ensure proper 401 responses for unauthenticated requests\n4. Verify req.user is correctly populated from session data\n5. Test all protected endpoints to ensure authentication works correctly\n\nThis is critical for application security before any production deployment.",
      "testStrategy": "1. Test that protected routes return 401 when no session cookie is sent\n2. Test that protected routes return 401 when session exists but userId is missing\n3. Test that protected routes allow access when valid session exists\n4. Verify req.user is correctly populated with session data\n5. Test logout functionality properly destroys sessions",
      "status": "done",
      "dependencies": [
        32,
        33
      ],
      "priority": "high",
      "subtasks": []
    },
    {
      "id": 36,
      "title": "BE: Restore OpenAPI Cookie Authentication Validation",
      "description": "Ensure the OpenAPI specification properly validates cookie authentication and that the cookieAuth security scheme is correctly configured for all protected endpoints.",
      "details": "1. Verify the cookieAuth security scheme is properly defined in openapi.yml components/securitySchemes\n2. Ensure all protected endpoints have the 'security: - cookieAuth: []' declaration\n3. Confirm the OpenAPI validation middleware correctly validates cookies before requests reach application middleware\n4. Test that OpenAPI validation rejects requests without proper cookies\n5. Ensure API documentation accurately reflects authentication requirements\n\nThis provides the first line of defense and ensures API documentation accuracy.",
      "testStrategy": "1. Test that OpenAPI validation rejects requests without connect.sid cookie\n2. Test that OpenAPI validation rejects requests with invalid session IDs\n3. Verify protected endpoints in API docs show authentication requirement\n4. Test that valid authenticated requests pass OpenAPI validation\n5. Confirm error responses match OpenAPI specification",
      "status": "pending",
      "dependencies": [
        31,
        35
      ],
      "priority": "high",
      "subtasks": []
    },
    {
      "id": 37,
      "title": "Test AI Functionality with Google API Key",
      "description": "Perform comprehensive testing to verify that the Task Master AI features, integrated with the newly added Google API key, are operating correctly and delivering accurate results.",
      "details": "This task involves end-to-end testing of all AI-powered functionalities within the Task Master application.\nKey objectives include:\n1.  Confirmation that the Google API key is correctly configured and utilized by the AI modules.\n2.  Identification and systematic testing of each specific AI feature (e.g., AI-assisted task description generation, dependency suggestion, content summarization, etc.).\n3.  Validation of AI feature inputs, processing logic (at a high level), and output accuracy and relevance.\n4.  Ensuring backend services/APIs supporting these AI features are stable and responsive.\n5.  Verifying robust error handling for scenarios such as Google API errors (e.g., quota limits, invalid key, network connectivity issues) or invalid inputs to AI features.",
      "testStrategy": "1. **Environment & Configuration Verification**:\n    *   Confirm the Google API key is securely configured and accessible in the testing environment.\n    *   Ensure all AI-related modules/services are deployed and running.\n2.  **AI Feature Inventory & Test Case Design**:\n    *   Compile an exhaustive list of all implemented Task Master AI features.\n    *   For each feature, design specific test cases covering:\n        *   **Positive Scenarios**: Valid inputs expected to yield successful AI processing and relevant outputs.\n        *   **Edge Cases**: Inputs that test the boundaries of expected behavior.\n        *   **Negative Scenarios (Input Validation)**: Invalid or malformed inputs to ensure graceful error handling by the system before AI invocation (if applicable).\n3.  **Functional Testing (Per AI Feature)**:\n    *   Execute positive test cases: Provide valid inputs and meticulously verify the AI-generated output for accuracy, relevance, and correct formatting.\n    *   Execute edge case test cases: Observe system behavior and AI output.\n    *   Execute negative input test cases: Confirm user-friendly error messages and system stability.\n4.  **Google API Interaction & Error Handling Tests**:\n    *   Simulate Google API unavailability or errors (if feasible in a controlled test environment, e.g., by temporarily revoking/misconfiguring the key or using mock services that simulate error responses).\n    *   Verify that the Task Master application handles these external errors gracefully (e.g., informative messages to the user, proper logging, no crashes).\n    *   Test with a valid key that might hit a (test) quota limit if possible, to see how that's handled.\n5.  **Output Validation**:\n    *   For features generating text or suggestions, assess the quality, coherence, and usefulness of the AI output against predefined criteria or expert judgment.\n    *   For features making predictions or classifications, compare results against known outcomes if possible.\n6.  **Logging & Monitoring Review**:\n    *   Inspect application logs during testing for any errors, warnings, or unexpected behavior related to AI feature execution or Google API calls.\n    *   Verify that successful operations and significant errors are logged appropriately for diagnostics.\n7.  **Basic Performance Check**:\n    *   For interactive AI features, assess if the response time is acceptable from a user experience perspective. This is an observational check, not a formal load test.",
      "status": "pending",
      "dependencies": [
        35,
        36
      ],
      "priority": "low",
      "subtasks": []
    },
    {
      "id": 38,
      "title": "Simple MCP AI Functionality Verification",
      "description": "Perform a targeted, simple test to confirm a core capability of the MCP AI (Task Master AI) is functioning as expected, post-integration with the Google API key and initial comprehensive testing.",
      "details": "1. Prerequisite: MCP AI (Task Master AI) has been integrated with the Google API key and has undergone comprehensive testing (as per Task 37).\n2. Identify a single, straightforward AI function to test. Example: Given a short user story, the AI should generate 3 relevant tags.\n3. Input: A specific, concise user story (e.g., \"As a user, I want to reset my password so I can regain access to my account.\").\n4. Expected Output: A list of 3 relevant tags (e.g., [\"password reset\", \"account recovery\", \"security\"]). The expected tags should be predefined for the chosen test case.\n5. Execution:\n    a. Access the MCP AI interface or API endpoint.\n    b. Provide the defined input user story.\n    c. Capture the AI's generated tags.",
      "testStrategy": "1. Verify the MCP AI endpoint is accessible and responsive.\n2. Submit the predefined user story to the AI.\n3. Collect the generated tags from the AI's response.\n4. Compare the generated tags against the predefined expected tags. The test passes if the generated output sufficiently matches the expected output (e.g., at least 2 out of 3 tags match or are clear semantic equivalents, or as defined by the specific test case criteria).\n5. Document the input, expected output, actual output, and pass/fail result. Note any discrepancies or unexpected behavior for further review.",
      "status": "done",
      "dependencies": [
        37
      ],
      "priority": "low",
      "subtasks": []
    },
    {
      "id": 39,
      "title": "BE: Implement Google OAuth 2.0 Login Integration",
      "description": "Integrate Google OAuth 2.0 to allow users to sign in or register using their Google accounts. This involves backend setup for the OAuth flow, handling Google's callback, and managing user account creation/linking and session state.",
      "details": "### 1. Google Cloud Project Setup:\n   - Navigate to the Google Cloud Console.\n   - Create a new project or select an existing one.\n   - Enable the \"Google People API\" under \"APIs & Services -> Enabled APIs & Services\".\n   - Configure the OAuth consent screen under \"APIs & Services -> OAuth consent screen\":\n     - Specify User Type (e.g., External).\n     - Provide App name, User support email, App logo (optional).\n     - Add Scopes: `openid`, `https://www.googleapis.com/auth/userinfo.email`, `https://www.googleapis.com/auth/userinfo.profile`.\n     - Fill in developer contact information.\n   - Create OAuth 2.0 Client ID under \"APIs & Services -> Credentials\":\n     - Select Application type: \"Web application\".\n     - Name it (e.g., \"Exchange App Web Client\").\n     - Add Authorized JavaScript origins (e.g., frontend URL like `http://localhost:3001`).\n     - Add Authorized redirect URIs for the backend (e.g., `http://localhost:3000/api/auth/google/callback`).\n     - Securely store the generated Client ID and Client Secret (e.g., in environment variables).\n\n### 2. Backend Implementation (using Passport.js):\n   - Install necessary packages: `npm install passport passport-google-oauth20 express-session`.\n   - Ensure `express-session` middleware is configured and initialized before Passport middleware. This might be partially covered by Task 4 but ensure it's compatible with Passport's session needs.\n   - Initialize Passport middleware: `app.use(passport.initialize()); app.use(passport.session());`.\n   - Configure `passport-google-oauth20` strategy:\n     ```javascript\n     passport.use(new GoogleStrategy({\n       clientID: process.env.GOOGLE_CLIENT_ID,\n       clientSecret: process.env.GOOGLE_CLIENT_SECRET,\n       callbackURL: '/api/auth/google/callback',\n       scope: ['profile', 'email']\n     },\n     async (accessToken, refreshToken, profile, done) => {\n       try {\n         const googleId = profile.id;\n         const email = profile.emails && profile.emails[0] ? profile.emails[0].value : null;\n         const firstName = profile.name ? profile.name.givenName : '';\n         const lastName = profile.name ? profile.name.familyName : '';\n\n         if (!email) {\n           return done(new Error('Email not provided by Google.'), null);\n         }\n\n         let user = await User.findOne({ where: { googleId: googleId } });\n         if (user) {\n           return done(null, user);\n         }\n\n         user = await User.findOne({ where: { email: email } });\n         if (user) {\n           // Link Google ID to existing email account\n           user.googleId = googleId;\n           // Optionally update name fields if they are empty or prefer Google's\n           user.firstName = user.firstName || firstName;\n           user.lastName = user.lastName || lastName;\n           user.isEmailVerified = true; // Google verifies email\n           await user.save();\n           return done(null, user);\n         }\n\n         // Create new user\n         const newUser = await User.create({\n           googleId: googleId,\n           email: email,\n           firstName: firstName,\n           lastName: lastName,\n           isEmailVerified: true, // Email from Google is considered verified\n           // Password field can be null or a placeholder if schema requires it for OAuth users\n           // Ensure User model (from Task 3) accommodates this\n         });\n         return done(null, newUser);\n       } catch (err) {\n         return done(err, null);\n       }\n     }));\n     ```\n   - Implement Passport `serializeUser` and `deserializeUser` for session management:\n     ```javascript\n     passport.serializeUser((user, done) => {\n       done(null, user.id); // Assuming user object has an 'id' property (PK)\n     });\n\n     passport.deserializeUser(async (id, done) => {\n       try {\n         const user = await User.findByPk(id);\n         done(null, user);\n       } catch (err) {\n         done(err);\n       }\n     });\n     ```\n   - Update User model/schema (from Task 2/3) to include `googleId` (String, unique, nullable), `firstName`, `lastName`, and `isEmailVerified` (Boolean) fields if not already present.\n\n### 3. API Routes:\n   - **`GET /api/auth/google`**: Initiates the Google OAuth flow.\n     ```javascript\n     router.get('/auth/google', passport.authenticate('google'));\n     ```\n   - **`GET /api/auth/google/callback`**: Handles the callback from Google.\n     ```javascript\n     router.get('/auth/google/callback',\n       passport.authenticate('google', {\n         successRedirect: process.env.GOOGLE_OAUTH_SUCCESS_REDIRECT_URL || '/dashboard',\n         failureRedirect: process.env.GOOGLE_OAUTH_FAILURE_REDIRECT_URL || '/login?error=google_auth_failed',\n         failureMessage: true // Store failure message in req.session.messages\n       })\n     );\n     ```\n   - Ensure these routes adhere to OpenAPI specifications (Task 31) and centralized error handling (Task 32).\n\n### 4. Session Management:\n   - Successful authentication via Passport will establish a session using `express-session` and populate `req.user`.\n   - This session should be compatible with the authentication middleware from Task 4.",
      "testStrategy": "### 1. Unit Tests (e.g., Jest, Mocha):\n   - Test the Passport strategy's verify callback logic extensively:\n     - Mock `User.findOne`, `User.create`, `user.save`.\n     - Scenario: User found by `googleId`.\n     - Scenario: User found by `email` (account linking), verify `googleId` and `isEmailVerified` are updated.\n     - Scenario: New user creation, verify all fields are set correctly.\n     - Scenario: Google profile does not provide an email.\n     - Scenario: Database errors during find or save operations.\n   - Test `serializeUser` and `deserializeUser` with mock user objects and IDs.\n\n### 2. Integration Tests (e.g., Supertest):\n   - Test `GET /api/auth/google` endpoint:\n     - Verify it returns a 302 redirect.\n     - Verify the `Location` header in the response points to Google's OAuth URL with correct parameters (client_id, redirect_uri, scope, response_type).\n   - Test `GET /api/auth/google/callback` (requires mocking Google's response or a more complex setup):\n     - Simulate a successful callback from Google: Mock `passport.authenticate` or the strategy execution to return a mock user.\n       - Verify session cookie is set.\n       - Verify redirection to `successRedirect` URL.\n     - Simulate a failed callback from Google:\n       - Verify redirection to `failureRedirect` URL.\n       - Verify appropriate error message is available (e.g., in session or query param).\n\n### 3. Manual End-to-End Testing:\n   - **Prerequisites**: Frontend with a \"Sign in with Google\" button pointing to `/api/auth/google`.\n   - **Scenario 1: New User Registration**\n     - Use a Google account not previously registered in the application.\n     - Click \"Sign in with Google\", authenticate with Google, grant permissions.\n     - Verify successful redirection to the application's dashboard or specified success URL.\n     - Check database: A new user record should exist with `googleId`, email, name from Google, and `isEmailVerified` set to true.\n     - Verify session is active and user can access protected routes.\n   - **Scenario 2: Existing Google User Login**\n     - Log out. Use the same Google account from Scenario 1.\n     - Click \"Sign in with Google\".\n     - Verify successful login and redirection without creating a new user account.\n   - **Scenario 3: Linking Google to Existing Email Account**\n     - Create an account using traditional email/password (e.g., `test.user@example.com`).\n     - Log out. Click \"Sign in with Google\" using a Google account associated with `test.user@example.com`.\n     - Verify successful login. Check database: The existing user record for `test.user@example.com` should now have its `googleId` field populated and `isEmailVerified` set to true.\n   - **Scenario 4: Google Authentication Failure**\n     - On Google's consent screen, deny permission or simulate an error from Google's side.\n     - Verify redirection to the specified `failureRedirect` URL with an appropriate error indicator.\n   - **Scenario 5: Session Persistence**\n     - After logging in with Google, close and reopen the browser (if session is persistent) or navigate within the app.\n     - Verify the user remains logged in and the session is correctly managed by the middleware from Task 4.\n\n### 4. Security Checks:\n   - Verify Client ID and Client Secret are stored securely as environment variables and not exposed client-side.\n   - Ensure the `redirect_uri` configured in Google Cloud Console exactly matches the one used by the backend to prevent open redirector vulnerabilities.",
      "status": "pending",
      "dependencies": [
        3,
        4,
        31,
        32,
        33
      ],
      "priority": "medium",
      "subtasks": []
    },
    {
      "id": 40,
      "title": "Refactor Validation to Express.js Middleware with Valibot",
      "description": "Refactor existing validation logic from service layers to a centralized Express.js middleware pattern using Valibot schemas. This will improve separation of concerns and standardize error handling for request validation.",
      "details": "This task involves creating reusable Express.js middleware for request validation using the Valibot schemas developed in Task 33. Key steps include:\n1. Develop a generic validation middleware factory function. This function should accept a Valibot schema as an argument.\n2. The middleware should parse and validate `req.body`, `req.params`, and `req.query` against the provided schema.\n3. Upon successful validation, the middleware should call `next()` to pass control to the next handler. If Valibot parsing results in transformed/parsed data, it should be attached to `req` (e.g., `req.validatedData = parsedOutput`).\n4. If validation fails, the middleware must not call `next()`. Instead, it should immediately respond with a 400 Bad Request status and a JSON body detailing the validation errors, utilizing Valibot's error reporting capabilities for clear messages.\n5. Identify all routes currently performing validation within their service/controller logic.\n6. Integrate the new validation middleware into these Express routes, applying the appropriate Valibot schema for each.\n   Example: `router.post('/resource', validationMiddleware(resourceCreateSchema), resourceController.createResource);`\n7. Remove all data validation logic from the service layer methods. Services should now assume that incoming data has been pre-validated and is schema-compliant.\n8. Ensure that this refactoring centralizes validation error handling, providing consistent error responses across the API for input validation issues.",
      "testStrategy": "Verify the correct implementation through a combination of unit and integration tests:\n1. **Unit Tests for Validation Middleware**:\n   - Create test suites for the generic validation middleware factory.\n   - Test with various Valibot schemas (covering `body`, `params`, `query`).\n   - Mock `req`, `res`, `next` objects.\n   - Assert that `next()` is called when provided with valid data matching the schema.\n   - Assert that `res.status(400).json()` is called with a correctly structured error payload (derived from Valibot errors) when provided with invalid data, and `next()` is not called.\n   - Verify that parsed and validated data is correctly attached to the `req` object if applicable.\n2. **Integration Tests for Routes**:\n   - For each API endpoint refactored to use the new validation middleware:\n     - Send requests with valid payloads: Confirm the request passes validation, reaches the controller/service, and returns the expected successful response (e.g., 200 OK, 201 Created).\n     - Send requests with various invalid payloads (e.g., missing required fields, incorrect data types, values violating schema constraints): Confirm a 400 Bad Request response is returned with a JSON body detailing the specific validation errors. Ensure the underlying service logic is not executed.\n3. **Service Layer Tests Verification**:\n   - Review and update existing service layer tests to ensure they no longer test for input validation that is now handled by the middleware. Service tests should focus on business logic, assuming valid inputs.\n4. **Manual API Testing**:\n   - Use an API client (e.g., Postman) to manually test a selection of refactored endpoints with diverse valid and invalid inputs to confirm behavior and consistent error responses.",
      "status": "pending",
      "dependencies": [
        33
      ],
      "priority": "medium",
      "subtasks": []
    }
  ]
}